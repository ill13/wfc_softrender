All files from 'WaveFunctionCollapse'
Generated: 2025-09-05 22:12:35
Mode: all
Included extensions: tsx, css, gif, webp, ini, less, jpeg, vue, yml, tiff, json, yaml, toml, ts, bmp, js, html, scss, cfg, png, jsx, svg, py, txt, sass, jpg
Tiktoken available: True
Encoding: cl100k_base
==================================================

==================================================
FILE: index.html
MODIFIED: 2025-09-05 17:57:23
TOKENS: [92m1,052[0m
==================================================

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Wave Function Collapse - Smart Location Placement</title>
    <link rel="stylesheet" href="css/style.css" />
  </head>
  <body>
    <div class="container">
      <!-- Header -->
      <header class="header">
        <h1>Wave Function Collapse Map</h1>
        <p>Smart Locations + Data-Driven Terrain</p>
      </header>

      <!-- Controls -->
      
      <div class="controls">
        <!-- Map Name and Generate Buttons -->
        <div class="top-controls">
          <div class="map-name-group">
            <!-- <label for="mapNameInput">Map Name</label> -->
            <div class="input-with-copy">
              <input type="text" id="mapNameInput" class="input-text" placeholder="A Mysterious Place" />
              <button id="copyMapNameBtn" title="Copy map name" aria-label="Copy name">üìã</button>
            </div>
          </div>

          <div class="button-group">
            <button id="generateBtn">Generate New World</button>
            <button id="stepBtn">Step Forward</button>
            <button id="autoBtn">Auto Generate</button>
            <button id="resetBtn">Reset</button>
          </div>
        </div>

        <!-- Grid Size moved to sidebar -->
      </div>

      <!-- Main Content -->
      <div class="main-content">
        <div class="map-area">
          <div id="mapGrid" class="map-grid"></div>
        </div>

        <aside class="sidebar">
          <div class="info-section">
            <h3>Theme</h3>
            <select id="themeSelect">
              <option value="fantasy">üè∞ Fantasy</option>
              <option value="cyberpunk">üåÉ Cyberpunk</option>
              <option value="modern">üö≤ Modern</option>
            </select>
          </div>

          <div class="info-section">
            <h3>Grid Size</h3>
            <div class="grid-size">
              <input type="number" id="gridWidth" value="8" min="4" max="24" />
              <span>√ó</span>
              <input type="number" id="gridHeight" value="8" min="4" max="24" />
            </div>
          </div>

          <div class="info-section">
            <h3>Progress</h3>
            <div class="progress-bar-container">
              <div id="progressBar" class="progress-bar">0%</div>
            </div>
            <div class="speed-controls">
              <button id="slowBtn">Slow</button>
              <button id="normalBtn">Normal</button>
              <button id="fastBtn">Fast</button>
            </div>
          </div>

          <div class="info-section">
            <h3>Terrain Legend</h3>
            <div id="legend" class="legend"></div>
          </div>

          <div class="info-section">
            <h3>Statistics</h3>
            <div class="stats">
              <div class="stat"><span>Steps:</span> <span id="stepCount">0</span></div>
              <div class="stat"><span>Locations:</span> <span id="locationCount">0</span></div>
              <div class="stat"><span>Entropy:</span> <span id="entropyCount">0</span></div>
              <div class="stat"><span>Collapsed:</span> <span id="collapsedCount">0</span></div>
            </div>
          </div>

          <div class="info-section">
            <h3>Log</h3>
            <div id="log" class="log"></div>
          </div>
        </aside>
      </div>
    </div>

    <!-- Scripts -->
    <script async src="https://stats.ill13.com/script.js" data-website-id="acd6458a-bc5c-4a87-92a2-4ca46d461135"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/seedrandom/3.0.5/seedrandom.min.js"></script>
    <script src="js/loader.js"></script>
    <script src="js/themeManager.js"></script>
    <script src="js/classes/MapNamer.js"></script>
    <script src="js/classes/WaveFunctionCollapse.js"></script>
    <script src="js/TemplatePlacer.js"></script>
    <script src="js/classes/SoftRenderer.js"></script>
    <script src="js/main.js"></script>
  </body>
</html>


==================================================
FILE: css\style.css
MODIFIED: 2025-09-05 21:36:07
TOKENS: [92m2,124[0m
==================================================

/* === Global Styles === */
:root {
  --bg-primary: linear-gradient(135deg, #1a2a1a, #2d3d20);
  --bg-panel: #3a2818;
  --border-primary: #5d4037;
  --border-accent: #d4af37;
  --text-primary: #e8dcc5;
  --text-gold: #d4af37;
  --padding: 16px;
  --border-radius: 6px;
  --shadow: 0 0 20px rgba(0, 0, 0, 0.5), inset 0 0 0 2px rgba(212, 175, 55, 0.2);
}





* {
  box-sizing: border-box;
}

body {
  margin: 0;
  padding: 8px;
  font-family: 'Consolas', monospace;
  background: var(--bg-primary);
  color: var(--text-primary);
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

.container {
  max-width: 1200px;
  margin: 0 auto;
  width: 100%;
}

/* === Header === */
.header {
  text-align: center;
  margin-bottom: 20px;
  padding: 20px;
  background: var(--bg-panel);
  border: 1px solid var(--border-accent);
  border-radius: var(--border-radius);
  color: var(--text-gold);
}

.header h1 {
  margin: 0;
  font-size: 2rem;
  letter-spacing: 1px;
}

.header p {
  margin: 8px 0 0;
  font-size: 0.9rem;
  opacity: 0.8;
}

/* === Controls === */
.controls {
  display: flex;
  flex-direction: column;
  gap: 16px;
  padding: 16px;
  background: var(--bg-panel);
  border: 1px solid var(--border-primary);
  border-radius: var(--border-radius);
  margin-bottom: 16px;
}

.top-controls {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  gap: 16px;
  flex-wrap: wrap;
}


.map-name-group {
  min-width: 200px;
  display: flex;
  flex-direction: column;
  gap: 8px;
  flex-shrink: 0; /* Prevents horizontal stretching */
}

.map-name-group label {
  font-size: 0.9rem;
  color: var(--text-gold);
  margin: 0;
}

.map-name-group .input-text,
.grid-size input[type="number"] {
  padding: 8px 12px;
  background: rgba(0, 0, 0, 0.3);
  border: 1px solid var(--border-primary);
  color: var(--text-primary);
  border-radius: 4px;
  font-family: 'Consolas', monospace;
  font-size: 14px;
  outline: none;
}

.map-name-group .input-text:focus {
  border-color: var(--text-gold);
  box-shadow: 0 0 0 2px rgba(212, 175, 55, 0.2);
}

.map-name-group .input-with-copy {
  display: flex;
  align-items: center;
  gap: 8px;
  width: 100%;
}

.map-name-group button {
  margin: 0;
  padding: 6px 12px;
  font-size: 12px;
  background: var(--border-accent);
  color: var(--bg-panel);
  border: none;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.map-name-group button:hover {
  background: #f0c855;
  transform: translateY(-1px);
}

.canvas{
    position: fixed;
}

.button-group {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  flex: 1;
  margin-top: 0;
  align-self: flex-start;
}

.button-group button {
  padding: 10px 16px;
  background: var(--bg-panel);
  color: var(--text-gold);
  border: 1px solid var(--border-accent);
  border-radius: 4px;
  font-family: 'Consolas', monospace;
  font-size: 14px;
  cursor: pointer;
  transition: all 0.2s ease;
  margin: 0;
}

.button-group button:hover {
  background: #4a3a2a;
}

button:active {
  transform: scale(0.98);
}

/* === Main Content === */
.main-content {
  display: flex;
  flex-direction: column;
  gap: 16px;
}

@media (min-width: 768px) {
  .main-content {
    flex-direction: row;
  }
}

.map-area {
  flex: 1;
  background: #1a2a1a;
  border: 2px solid var(--border-accent);
  border-radius: var(--border-radius);
  box-shadow: var(--shadow);
  position: relative;
  min-height: 400px;
  display: flex;
  justify-content: center;
  align-items: center;
  overflow: hidden;
}

.map-grid {
  display: grid;
  gap: 0;
  border: none;
}

/* .tile {
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  transition: all 0.2s ease;
  height: 100%;
  width: 100%;
}
 */


.tile {
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  transition: all 0.2s ease;
  height: 100%;
  width: 100%;
  /* Hide background and borders */
  /* background: transparent !important; */
  box-shadow: none !important;
  border: none !important;
  /* Optional: hide emoji/text if you want pure paint */
  /* color: transparent !important; */
}



.tile.location {
  z-index: 2;
  scale: 100%;
}

.tile.uncollapsed {
  background: #374151;
  color: transparent;
}

/* === Sidebar === */
.sidebar {
  flex: 0 0 300px;
  background: var(--bg-panel);
  border: 1px solid var(--border-primary);
  border-radius: var(--border-radius);
  padding: var(--padding);
  color: var(--text-primary);
}

.info-section {
  margin-bottom: 16px;
}

.info-section h3 {
  margin: 0 0 10px;
  color: var(--text-gold);
  font-size: 1.1rem;
}

.grid-size {
  display: flex;
  align-items: center;
  gap: 4px;
  font-size: 14px;
}

.grid-size input[type="number"] {
  width: 60px;
  padding: 6px;
  text-align: center;
}

/* === Progress Bar === */
.progress-bar-container {
  width: 100%;
  height: 20px;
  background: #2a2a2a;
  border-radius: 4px;
  overflow: hidden;
  margin: 10px 0;
}

.progress-bar {
  height: 100%;
  background: var(--border-accent);
  transition: width 0.3s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  color: #000;
}

/* === Speed Controls === */
.speed-controls {
  display: flex;
  gap: 8px;
  margin-top: 10px;
}

.speed-controls button {
  flex: 1;
  padding: 6px;
  font-size: 12px;
}

/* === Legend === */
.legend {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
  gap: 8px;
  font-size: 12px;
}

.legend-item {
  display: flex;
  align-items: center;
  gap: 6px;
}

.legend-tile {
  width: 16px;
  height: 16px;
  border-radius: 2px;
}

/* === Stats === */
.stats {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px;
  font-size: 12px;
}

.stat {
  text-align: center;
  padding: 8px;
  background: rgba(0,0,0,0.3);
  border-radius: 4px;
}

.stat span:first-child {
  font-size: 0.8rem;
  opacity: 0.7;
}

/* === Log === */
.log {
  background: rgba(0,0,0,0.5);
  padding: 10px;
  border-radius: 4px;
  max-height: 150px;
  overflow-y: auto;
  font-size: 11px;
  line-height: 1.4;
}

/* === Responsive === */
@media (max-width: 767px) {
  .top-controls {
    flex-direction: column;
    align-items: stretch;
  }

  .map-name-group,
  .button-group {
    width: 100%;
  }

  .controls {
    padding: 12px;
  }

  .button-group {
    flex-direction: column;
  }

  .map-area {
    min-height: 300px;
  }

  .sidebar {
    flex: 1;
    order: 2;
  }

  .main-content {
    flex-direction: column;
  }
}

#mapContainer {
  position: relative;
}


==================================================
FILE: js\loader.js
MODIFIED: 2025-09-04 15:33:54
TOKENS: [92m179[0m
==================================================

// js/loader.js
class DataLoader {
  static async loadTheme(themeName) {
    const res = await fetch(`themes/${themeName}.json`);
    const theme = await res.json();

    // Extract terrain rules and weights
    const TERRAIN_TYPES = {};
    Object.keys(theme.elevation).forEach((type) => {
      TERRAIN_TYPES[type] = {
        weight: theme.elevation[type].weight || 1,
        adjacent: theme.elevation[type].adjacent || [],
        colors: theme.elevation[type].colors || ["#333"],
      };
    });

    const LOCATIONS = Object.entries(theme.locations).map(([id, loc]) => ({
      id,
      ...loc,
    }));
    const TEMPLATES = theme.templates || {};

    return { TERRAIN_TYPES, LOCATIONS, TEMPLATES, THEME: theme };
  }
}


==================================================
FILE: js\main.js
MODIFIED: 2025-09-05 21:50:31
TOKENS: [92m1,152[0m
==================================================

// js/main.js
let TERRAIN_TYPES, LOCATIONS;
let wfc;
let softRenderer = null;

async function initApp() {
  const themeName = document.getElementById("themeSelect").value;
  const data = await DataLoader.loadTheme(themeName);
  TERRAIN_TYPES = data.TERRAIN_TYPES;
  LOCATIONS = data.LOCATIONS;
  ThemeManager.setTheme(themeName);

  const width = parseInt(document.getElementById("gridWidth").value);
  const height = parseInt(document.getElementById("gridHeight").value);
  wfc = new WaveFunctionCollapse(width, height, themeName);
  updateLegend();
  setupEventListeners();
  wfc.updateUI();

  // Initialize SoftRenderer once mapGrid exists
  const mapGrid = document.getElementById("mapGrid");
  softRenderer = new SoftRenderer(mapGrid);

  //Inside initApp(), after wfc.updateUI();
  //  const mapGrid = document.getElementById("mapGrid");
  // if (!window.softRenderer && mapGrid) {
  //   window.softRenderer = new SoftRenderer(mapGrid);
  // }
  softRenderer?.update();
}

function updateLegend() {
  const legendEl = document.getElementById("legend");
  legendEl.innerHTML = "";
  const theme = ThemeManager.current;
  Object.keys(theme.elevation).forEach((type) => {
    const visual = theme.elevation[type];
    const item = document.createElement("div");
    item.className = "legend-item";
    const tile = document.createElement("div");
    tile.className = "legend-tile";
    tile.style.backgroundColor = visual.colors[0];
    const label = document.createElement("span");
    label.textContent = visual.label;
    item.appendChild(tile);
    item.appendChild(label);
    legendEl.appendChild(item);
  });
}

function setupEventListeners() {
  // Copy Map Name Button
  document.getElementById("copyMapNameBtn").addEventListener("click", () => {
    const input = document.getElementById("mapNameInput");
    const text = input.value || input.placeholder;

    navigator.clipboard
      .writeText(text)
      .then(() => {
        const btn = document.getElementById("copyMapNameBtn");
        const original = btn.textContent;
        btn.textContent = "‚úÖ Copied!";
        setTimeout(() => (btn.textContent = original), 2000);
      })
      .catch((err) => {
        console.warn("Copy failed:", err);
        alert("Could not copy to clipboard: " + err);
      });
  });

  document.getElementById("generateBtn").addEventListener("click", () => {
    const w = parseInt(document.getElementById("gridWidth").value);
    const h = parseInt(document.getElementById("gridHeight").value);
    const themeName = document.getElementById("themeSelect").value;
    wfc = new WaveFunctionCollapse(w, h, themeName);

    // ‚úÖ Force SoftRenderer to reset canvas and redraw state
    softRenderer?.reset();

    wfc.autoGenerate();
  });

  document.getElementById("stepBtn").addEventListener("click", () => {
    if (!wfc.isGenerating) wfc.step();
  });

  document.getElementById("autoBtn").addEventListener("click", () => {
    const btn = document.getElementById("autoBtn");
    if (wfc.isGenerating) {
      wfc.isGenerating = false;
      btn.textContent = "Auto Generate";
    } else {
      btn.textContent = "Auto Step";
      wfc.autoGenerate();
    }
  });

  document.getElementById("resetBtn").addEventListener("click", () => {
    const w = parseInt(document.getElementById("gridWidth").value);
    const h = parseInt(document.getElementById("gridHeight").value);
    const themeName = document.getElementById("themeSelect").value;
    wfc = new WaveFunctionCollapse(w, h, themeName);
    // ‚úÖ Force SoftRenderer to reattach to new grid
    const mapGrid = document.getElementById("mapGrid");
    if (softRenderer) {
      softRenderer.gridEl = mapGrid;
      softRenderer.lastGridEl = null; // Force reset on next update
    }
    wfc.updateUI();
  });

  document.getElementById("slowBtn").addEventListener("click", () => (wfc.autoSpeed = 300));
  document.getElementById("normalBtn").addEventListener("click", () => (wfc.autoSpeed = 100));
  document.getElementById("fastBtn").addEventListener("click", () => (wfc.autoSpeed = 30));

  document.getElementById("themeSelect").addEventListener("change", async () => {
    const themeName = document.getElementById("themeSelect").value;
    const data = await DataLoader.loadTheme(themeName);
    TERRAIN_TYPES = data.TERRAIN_TYPES;
    LOCATIONS = data.LOCATIONS;
    ThemeManager.setTheme(themeName);
    const w = parseInt(document.getElementById("gridWidth").value);
    const h = parseInt(document.getElementById("gridHeight").value);
    wfc = new WaveFunctionCollapse(w, h, themeName);
    wfc.updateUI();
  });
}

// Press 'H' to hide/show base tiles (for dev)
document.addEventListener("keydown", (e) => {
  if (e.key === "h" || e.key === "H") {
    console.log("hide/unhide");
    const tiles = document.querySelectorAll(".tile");
    const isVisible = tiles[0]?.style.color !== "transparent";
    document.querySelectorAll(".tile").forEach((t) => {
      t.style.color = isVisible ? "transparent" : "";
      t.style.backgroundColor = "transparent";
    });
  }
});

// Start
document.addEventListener("DOMContentLoaded", async () => {
  await ThemeManager.loadThemes();
  initApp();
});


==================================================
FILE: js\TemplatePlacer.js
MODIFIED: 2025-09-04 15:17:15
TOKENS: [92m643[0m
==================================================

// js/TemplatePlacer.js
class TemplatePlacer {
    static applyTo(wfc, templates) {
        if (!templates || Object.keys(templates).length === 0) return;

        const templateList = Object.entries(templates).map(([id, t]) => ({ id, ...t }));

        const numToApply = Math.floor(Math.random() * 2) + 1;
        for (let i = 0; i < numToApply; i++) {
            if (templateList.length === 0) break;
            const template = this.getRandomTemplate(templateList);
            const applied = this.applyTemplateToGrid(template, wfc.grid, wfc.width, wfc.height);
            if (applied) {
                wfc.log(`üé® Applied template: ${template.id}`);
            }
        }
    }

    static getRandomTemplate(templates) {
        const totalWeight = templates.reduce((sum, t) => sum + t.weight, 0);
        let r = Math.random() * totalWeight;
        for (const template of templates) {
            r -= template.weight;
            if (r <= 0) return template;
        }
        return templates[0];
    }

    static getPlacementPosition(template, width, height) {
        const tWidth = template.pattern[0]?.length || 0;
        const tHeight = template.pattern.length || 0;
        if (tWidth === 0 || tHeight === 0) return { x: 0, y: 0 };

        let x, y;
        switch (template.placement) {
            case "center":
                x = Math.floor((width - tWidth) / 2);
                y = Math.floor((height - tHeight) / 2);
                break;
            case "top_left":
                x = 0;
                y = 0;
                break;
            default: // "any"
                x = Math.floor(Math.random() * (width - tWidth + 1));
                y = Math.floor(Math.random() * (height - tHeight + 1));
        }
        x = Math.max(0, Math.min(x, width - tWidth));
        y = Math.max(0, Math.min(y, height - tHeight));
        return { x, y };
    }

    static applyTemplateToGrid(template, grid, width, height) {
        const { x: startX, y: startY } = this.getPlacementPosition(template, width, height);
        const pattern = template.pattern;

        for (let dy = 0; dy < pattern.length; dy++) {
            for (let dx = 0; dx < pattern[dy].length; dx++) {
                const x = startX + dx;
                const y = startY + dy;
                const terrainType = pattern[dy][dx];
                if (terrainType === null || terrainType === "") continue;
                const cell = grid[y]?.[x];
                if (!cell) continue;
                cell.possibilities = [terrainType];
                cell.collapsed = false;
            }
        }
        return true;
    }
}

==================================================
FILE: js\themeManager.js
MODIFIED: 2025-09-04 15:27:11
TOKENS: [92m249[0m
==================================================

// js/themeManager.js
class ThemeManager {
    static themes = {};
    static current = null;

    static async loadThemes() {
        const themeFiles = ['fantasy', 'cyberpunk', 'modern'];
        const promises = themeFiles.map(async name => {
            const res = await fetch(`themes/${name}.json`);
            const theme = await res.json();
            this.themes[name] = theme;
        });
        await Promise.all(promises);
        this.current = this.themes.fantasy; // default
    }

    static setTheme(dataOrName) {
    let theme = null;

    if (typeof dataOrName === 'string') {
        theme = this.themes[dataOrName];
        if (!theme) {
            console.warn(`Theme "${dataOrName}" not found`);
            return;
        }
    } else {
        theme = dataOrName;
    }

    this.current = theme;
    window.wfc?.updateUI();
    updateLegend();
}

    // ‚úÖ ADD THIS METHOD BACK
    static getRandomColor(colors) {
        if (!colors || colors.length === 0) return "#333";
        return colors[Math.floor(Math.random() * colors.length)];
    }
}

==================================================
FILE: js\classes\MapNamer.js
MODIFIED: 2025-09-05 13:55:26
TOKENS: [92m1,195[0m
==================================================

// js/classes/MapNamer.js
class MapNamer {
  static generate_old(wfc) {
    const theme = wfc.themeName; // e.g., 'fantasy'

    // Gather data
    const grid = wfc.grid.flat();
    const terrainCount = {};
    const placedLocations = wfc.placedLocations;

    grid.forEach(cell => {
      if (cell.terrain) terrainCount[cell.terrain] = (terrainCount[cell.terrain] || 0) + 1;
    });

    // Dominant terrain
    const dominantTerrain = Object.keys(terrainCount).reduce((a, b) =>
      terrainCount[a] > terrainCount[b] ? a : b
    );

    // Get label from theme
    const themeData = ThemeManager.current;
    const terrainLabel = themeData.elevation[dominantTerrain]?.label || "Unknown";

    // Iconic location (rarest or most special)
    const iconicLocation = placedLocations.length > 0
      ? placedLocations.sort((a, b) => {
        const aWeight = TERRAIN_TYPES[a.loc.id]?.weight || 1;
        const bWeight = TERRAIN_TYPES[b.loc.id]?.weight || 1;
        return aWeight - bWeight; // lower weight = rarer
      })[0]?.loc.name
      : null;

    // Adjectives by theme
    const adjectives = {
      fantasy: ["Sacred", "Ancient", "Whispering", "Cursed", "Hidden", "Eternal", "Forgotten"],
      cyberpunk: ["Abandoned", "Neon", "Fractured", "Silent", "Bleeding", "Data-Lit", "Fallen"],
      modern: ["Quiet", "Tree-Lined", "Busy", "Riverside", "Hillside", "Empty", "Sunlit"]
    };

    const adj = adjectives[theme] ? adjectives[theme][Math.floor(Math.random() * adjectives[theme].length)] : "Mysterious";

    // Name patterns
    const patterns = [
      `${adj} ${terrainLabel}`,
      `${iconicLocation ? iconicLocation : `The ${adj} Site`} in the ${terrainLabel}`,
      `${iconicLocation ? `${iconicLocation} of` : `The ${adj} Realm of`} the ${terrainLabel}`,
      `The ${adj} ${iconicLocation || "Place"} by the ${terrainLabel}`,
      `Where the ${terrainLabel} Begins`
    ];

    return patterns[Math.floor(Math.random() * patterns.length)];
  }




static generate(wfc) {
  const theme = wfc.themeName;
  const grid = wfc.grid.flat();

  // Count terrain types
  const terrainCount = {};
  grid.forEach(cell => {
    if (cell.terrain) terrainCount[cell.terrain] = (terrainCount[cell.terrain] || 0) + 1;
  });

  // Get dominant terrain with fallback
  let dominantTerrain;
  const terrainKeys = Object.keys(terrainCount);
  if (terrainKeys.length > 0) {
    dominantTerrain = terrainKeys.reduce((a, b) =>
      terrainCount[a] > terrainCount[b] ? a : b
    );
  } else {
    // Fallback: use the first terrain type from TERRAIN_TYPES
    dominantTerrain = Object.keys(TERRAIN_TYPES)[0] || "meadow"; // generic fallback
  }

  // Get label from theme
  const themeData = ThemeManager.current;
  const terrainLabel = themeData.elevation[dominantTerrain]?.label || "Unknown";

  // Iconic location (rarest or most special)
  const iconicLocation = wfc.placedLocations.length > 0
    ? wfc.placedLocations.sort((a, b) => {
        const aWeight = TERRAIN_TYPES[a.loc.id]?.weight || 1;
        const bWeight = TERRAIN_TYPES[b.loc.id]?.weight || 1;
        return aWeight - bWeight; // lower weight = rarer
      })[0]?.loc.name
    : null;

  // Adjectives by theme
  const adjectives = {
    fantasy: ["Sacred", "Ancient", "Whispering", "Cursed", "Hidden", "Eternal", "Forgotten"],
    cyberpunk: ["Abandoned", "Neon", "Fractured", "Silent", "Bleeding", "Data-Lit", "Fallen"],
    modern: ["Quiet", "Tree-Lined", "Busy", "Riverside", "Hillside", "Empty", "Sunlit"]
  };
  const adj = adjectives[theme] ? adjectives[theme][Math.floor(Math.random() * adjectives[theme].length)] : "Mysterious";

  // Name patterns
  const patterns = [
    `${adj} ${terrainLabel}`,
    `${iconicLocation ? iconicLocation : `The ${adj} Site`} in the ${terrainLabel}`,
    `${iconicLocation ? `${iconicLocation} of` : `The ${adj} Realm of`} the ${terrainLabel}`,
    `The ${adj} ${iconicLocation || "Place"} by the ${terrainLabel}`,
    `Where the ${terrainLabel} Begins`
  ];

  return patterns[Math.floor(Math.random() * patterns.length)];
}




  static stringToSeed(str) {
    let seed = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      seed = ((seed << 5) - seed + char) & 0xffffffff;
    }
    return Math.abs(seed) % 1000000;
  }
}

==================================================
FILE: js\classes\SoftRenderer.js
MODIFIED: 2025-09-05 21:36:55
TOKENS: [92m2,242[0m
==================================================

// js/classes/SoftRenderer.js
class SoftRenderer {
  constructor(mapGridElement) {
    this.gridEl = mapGridElement;
    this.canvas = null;
    this.ctx = null;
    this.tileSize = 0;
    this.width = 0;
    this.height = 0;
    this.rows = 0;
    this.cols = 0;
    this.drawn = new Set();
    this.lastGridEl = null;
    this.mapKey = null; // Track current map uniquely
    this.init();
  }

  init() {
    const rect = this.gridEl.getBoundingClientRect();
    this.tileSize = rect.width / Math.sqrt(this.gridEl.children.length);
    this.width = Math.round(rect.width);
    this.height = Math.round(rect.height);
    this.cols = Math.floor(this.width / this.tileSize);
    this.rows = Math.floor(this.height / this.cols);

    // Create or reuse canvas
    if (!this.canvas) {
      this.canvas = document.createElement("canvas");
      this.canvas.style.cssText = `
        position: fixed;
        pointer-events: none;
        z-index: 3;
        width: ${this.width}px;
        height: ${this.height}px;
      `;
      this.canvas.width = this.width;
      this.canvas.height = this.height;
      this.gridEl.parentElement.style.position = "relative"; // Ensure positioning context
      this.gridEl.parentElement.appendChild(this.canvas);
      this.ctx = this.canvas.getContext("2d");
    } else {
      // Resize existing canvas
      this.canvas.width = this.width;
      this.canvas.height = this.height;
      this.canvas.style.width = `${this.width}px`;
      this.canvas.style.height = `${this.height}px`;
    }

    this.ctx.resetTransform();
    this.ctx.imageSmoothingEnabled = false;

    // Apply border offset
    const border = parseInt(window.getComputedStyle(this.gridEl.parentElement).borderLeftWidth) || 0;
    this.ctx.translate(border, border);
  }

  reset() {
    // ‚úÖ Always fully clear canvas
    this.ctx.clearRect(0, 0, this.width, this.height);

    // ‚úÖ Reset composite mode before drawing background
    this.ctx.globalCompositeOperation = "source-over";

    // ‚úÖ Redraw clean parchment texture
    this.drawParchmentTexture();

    // ‚úÖ Reset drawn set for new map
    this.drawn.clear();

    // ‚úÖ Generate new map key to invalidate old draws
    this.mapKey = Date.now(); // Or use a UUID, but Date.now() suffices for now
  }

  update() {
    // If grid changed (new map), re-init and reset
    if (this.gridEl !== this.lastGridEl) {
      this.lastGridEl = this.gridEl;
      this.init(); // Recalculate sizes
      this.reset(); // Clear canvas, reset state
    }

    // ‚úÖ Always clear drawn set before full redraw
    // But we already do this in reset(), and we now redraw all tiles every frame
    // So let‚Äôs remove per-tile memoization within same map ‚Äî it‚Äôs unsafe during partial updates
    this.render();
  }

  render() {
    if (!this.ctx) return;

    const tiles = Array.from(this.gridEl.children);
    this.drawn.clear(); // üîÅ Clear every frame ‚Äî we do full redraw now

    tiles.forEach((tile, index) => {
      const x = index % this.cols;
      const y = Math.floor(index / this.cols);

      const bgColor = this.getTileColor(tile);
      if (!bgColor || bgColor === "rgb(55, 65, 81)") return; // Skip empty/ignored

      const style = this.getStyleForColor(bgColor);
      this.drawWatercolorSplotch(x, y, bgColor, style);
    });
  }

  getTileColor(tile) {
    const computed = window.getComputedStyle(tile).backgroundColor;
    return computed && computed !== "rgba(0, 0, 0, 0)" ? computed : null;
  }

  getStyleForColor(color) {
    const styleMap = {
      // Fantasy
      "rgb(119, 119, 119)": { scale: 1.1, offsetY: -4, blur: 6, alpha: 0.5 },
      "rgb(22, 163, 74)": { scale: 1.25, blur: 8, alpha: 0.4 },
      "rgb(163, 230, 53)": { scale: 1.2, blur: 6, alpha: 0.35 },
      "rgb(29, 78, 216)": { scale: 1.15, blur: 10, alpha: 0.5, flow: true },
      "rgb(124, 45, 18)": { scale: 0.85, alpha: 0.3, texture: "ash" },

      // Cyberpunk
      "rgb(84, 41, 92)": { scale: 1.2, blur: 12, alpha: 0.4, glow: "#33F0FF" },
      "rgb(70, 127, 161)": { scale: 1.0, blur: 4, alpha: 0.4 },
      "rgb(55, 65, 81)": { scale: 0.9, alpha: 0.3 },

      // Modern
      "rgb(14, 165, 233)": { scale: 1.2, blur: 10, alpha: 0.5 },
      "rgb(16, 185, 129)": { scale: 1.2, blur: 6, alpha: 0.4 },
      "rgb(22, 163, 74)": { scale: 1.1, blur: 5, alpha: 0.4 },
    };

    return styleMap[color] || { scale: 1.0, blur: 0, alpha: 0.4 };
  }

  drawWatercolorSplotch(x, y, color, style) {
    const { scale = 1.0, blur = 0, alpha = 0.4, offsetY = 0, glow, flow, texture } = style;

    const tx = x * this.tileSize;
    const ty = y * this.tileSize;
    const cx = tx + this.tileSize / 2;
    const cy = ty + this.tileSize / 2;
    const size = this.tileSize * scale;

    this.ctx.save();

    // Main pigment blobs
    this.ctx.shadowBlur = 0;
    for (let i = 0; i < 4; i++) {
      const angle = Math.random() * Math.PI * 2;
      const offset = (Math.random() - 0.5) * size * 0.3;
      const radius = size * (0.25 + Math.random() * 0.15);
      const dx = cx + Math.cos(angle) * offset;
      const dy = cy + Math.sin(angle) * offset + offsetY;

      this.ctx.beginPath();
      this.ctx.arc(dx, dy, radius, 0, Math.PI * 2);
      this.ctx.fillStyle = color;
      this.ctx.globalAlpha = alpha * (0.2 + Math.random() * 0.2);
      this.ctx.fill();
    }

    // Soft bleed edge
    if (blur > 0) {
      this.ctx.globalAlpha = alpha * 0.3;
      this.ctx.shadowColor = color;
      this.ctx.shadowBlur = blur * 1.5;
      this.ctx.beginPath();
      this.ctx.ellipse(cx, cy + offsetY, size * 0.6, size * 0.4, 0, 0, Math.PI * 2);
      this.ctx.fillStyle = color;
      this.ctx.fill();
    }

    // Flow effect
    if (flow) {
      this.ctx.globalAlpha = alpha * 0.2;
      this.ctx.shadowColor = color;
      this.ctx.shadowBlur = blur * 2;
      this.ctx.beginPath();
      this.ctx.ellipse(cx, cy + offsetY + 4, size * 0.7, size * 0.3, 0, 0, Math.PI * 2);
      this.ctx.fill();
    }

    // Glow (cyberpunk)
    if (glow) {
      this.ctx.globalAlpha = alpha * 0.2;
      this.ctx.shadowColor = glow;
      this.ctx.shadowBlur = blur * 2.5;
      this.ctx.beginPath();
      this.ctx.ellipse(cx, cy + offsetY, size * 0.5, size * 0.5, 0, 0, Math.PI * 2);
      this.ctx.stroke();
    }

    // Ash texture
    if (texture === "ash") {
      this.drawGrain(cx, cy, size, "#fff", 0.1);
    }

    this.ctx.restore();
  }

  drawParchmentTexture() {
    const ctx = this.ctx;
    const w = this.width;
    const h = this.height;
    const imageData = ctx.createImageData(w, h);
    for (let i = 0; i < imageData.data.length; i += 4) {
      const value = 245 + Math.random() * 10;
      const tint = Math.random() > 0.9 ? 10 : 0;
      imageData.data[i] = value + tint;         // R
      imageData.data[i + 1] = value - 10 + tint; // G
      imageData.data[i + 2] = value - 30;       // B
      imageData.data[i + 3] = 255;              // A
    }
    ctx.putImageData(imageData, 0, 0);

    // Use screen blend to lighten base
    ctx.globalCompositeOperation = "screen";
    ctx.fillStyle = "rgba(255, 255, 220, 0.1)";
    ctx.fillRect(0, 0, w, h);
    ctx.globalCompositeOperation = "source-over"; // Reset after
  }

  drawGrain(cx, cy, size, color, alpha) {
    this.ctx.save();
    this.ctx.globalAlpha = alpha;
    this.ctx.fillStyle = color;
    for (let i = 0; i < 6; i++) {
      const rx = cx - size / 2 + Math.random() * size;
      const ry = cy - size / 2 + Math.random() * size;
      this.ctx.fillRect(rx, ry, 1, 1);
    }
    this.ctx.restore();
  }
}

==================================================
FILE: js\classes\WaveFunctionCollapse.js
MODIFIED: 2025-09-05 21:51:34
TOKENS: [92m2,991[0m
==================================================

// js/classes/WaveFunctionCollapse.js
class WaveFunctionCollapse {
  constructor(width, height, themeName) {
    this.width = width;
    this.height = height;
    this.themeName = themeName;
    this.grid = [];
    this.stepCount = 0;
    this.locationCount = 0;
    this.isGenerating = false;
    this.autoSpeed = 0;
    this.placedLocations = [];
    this.mapName = "";
    this.init();
  }

  init() {
    this.grid = [];
    this.stepCount = 0;
    this.locationCount = 0;
    this.placedLocations = [];
    for (let y = 0; y < this.height; y++) {
      this.grid[y] = [];
      for (let x = 0; x < this.width; x++) {
        this.grid[y][x] = {
          possibilities: Object.keys(TERRAIN_TYPES),
          collapsed: false,
          terrain: null,
          location: null,
        };
      }
    }
    this.log(`Initialized ${this.width}x${this.height} grid`);
    this.updateUI();
  }

  getCell(x, y) {
    if (x < 0 || x >= this.width || y < 0 || y >= this.height) return null;
    return this.grid[y][x];
  }

  getNeighbors(x, y) {
    const directions = [[-1,0], [1,0], [0,-1], [0,1]];
    return directions
      .map(([dx, dy]) => ({ x: x + dx, y: y + dy, cell: this.getCell(x + dx, y + dy) }))
      .filter(n => n.cell);
  }

  findLowestEntropy() {
    let minEntropy = Infinity;
    let candidates = [];
    for (let y = 0; y < this.height; y++) {
      for (let x = 0; x < this.width; x++) {
        const cell = this.grid[y][x];
        if (!cell.collapsed && cell.possibilities.length < minEntropy) {
          minEntropy = cell.possibilities.length;
          candidates = [{ x, y }];
        } else if (!cell.collapsed && cell.possibilities.length === minEntropy) {
          candidates.push({ x, y });
        }
      }
    }
    return candidates.length > 0 ? candidates[Math.floor(Math.random() * candidates.length)] : null;
  }

  collapseCell(x, y) {
    const cell = this.grid[y][x];
    if (cell.collapsed) return false;

    let weights = {};
    for (const t of cell.possibilities) {
      let weight = TERRAIN_TYPES[t].weight;
      const neighborMatchCount = this.getNeighbors(x, y)
        .filter(n => n.cell.collapsed && n.cell.terrain === t).length;
      weight *= Math.pow(1.7, neighborMatchCount);
      weights[t] = weight;
    }

    const totalWeight = Object.values(weights).reduce((a, b) => a + b, 0);
    if (totalWeight === 0) return false;

    let r = Math.random() * totalWeight;
    let selected = cell.possibilities[0];
    for (const t of cell.possibilities) {
      r -= weights[t];
      if (r <= 0) {
        selected = t;
        break;
      }
    }

    const theme = ThemeManager.current;
    const terrainVisual = theme.elevation[selected];
    const chosenColor = ThemeManager.getRandomColor(terrainVisual.colors);

    cell.terrain = selected;
    cell.possibilities = [selected];
    cell.collapsed = true;
    cell.color = chosenColor;

    this.log(`Collapsed (${x}, ${y}) ‚Üí ${selected}`);
    return true;
  }

  propagate(x, y) {
    const queue = [{ x, y }];
    const processed = new Set();
    while (queue.length > 0) {
      const { x, y } = queue.shift();
      const key = `${x},${y}`;
      if (processed.has(key)) continue;
      processed.add(key);
      const neighbors = this.getNeighbors(x, y);
      for (const { x: nx, y: ny, cell: neighbor } of neighbors) {
        if (neighbor.collapsed) continue;
        const valid = neighbor.possibilities.filter((p) => {
          const allowed = TERRAIN_TYPES[p].adjacent;
          return this.getNeighbors(nx, ny).some(({ cell: nn }) => (nn.collapsed ? allowed.includes(nn.terrain) : true));
        });
        if (valid.length !== neighbor.possibilities.length) {
          neighbor.possibilities = valid;
          if (valid.length === 0) {
            this.log(`Contradiction at (${nx}, ${ny})`);
            return false;
          }
          queue.push({ x: nx, y: ny });
        }
      }
    }
    return true;
  }

  step() {
    if (this.isComplete()) return false;
    const cell = this.findLowestEntropy();
    if (!cell) return false;
    if (this.collapseCell(cell.x, cell.y)) {
      if (!this.propagate(cell.x, cell.y)) {
        this.log("Contradiction!");
        return false;
      }
      this.stepCount++;
      this.updateUI();
      const el = document.querySelector(`[data-pos="${cell.x},${cell.y}"]`);
      if (el) {
        el.classList.add("collapsed");
        setTimeout(() => el.classList.remove("collapsed"), 500);
      }
      return true;
    }
    return false;
  }

  isComplete() {
    return this.grid.flat().every(c => c.collapsed);
  }

  placeLocations() {
    const cells = [];
    for (let y = 0; y < this.height; y++) {
      for (let x = 0; x < this.width; x++) {
        if (!this.grid[y][x].location) {
          cells.push({ x, y });
        }
      }
    }

    const sortedLocations = [...LOCATIONS].sort((a, b) => {
      const countValid = (loc) => cells.filter((pos) => this.isValidLocationSpot(pos.x, pos.y, loc)).length;
      return countValid(a) - countValid(b);
    });

    for (const loc of sortedLocations) {
      const validSpots = cells.filter((pos) => this.isValidLocationSpot(pos.x, pos.y, loc));
      if (validSpots.length === 0) continue;
      const pick = validSpots[Math.floor(Math.random() * validSpots.length)];
      const { x, y } = pick;
      this.grid[y][x].location = loc;
      this.placedLocations.push({ x, y, loc });
      this.locationCount++;
      this.log(`üìç Placed ${loc.name} at (${x}, ${y})`);
      const idx = cells.findIndex(c => c.x === x && c.y === y);
      if (idx !== -1) cells.splice(idx, 1);
    }
  }

  isValidLocationSpot(x, y, location) {
    const cell = this.grid[y][x];
    if (cell.location) return false;
    const terrain = cell.terrain;
    const rules = location.rules;

    if (rules.on && !rules.on.includes(terrain)) return false;

    if (rules.adjacent && rules.adjacent.length > 0) {
      const neighborTerrains = this.getNeighbors(x, y)
        .filter(n => n.cell.collapsed)
        .map(n => n.cell.terrain);
      const hasAllRequired = rules.adjacent.every(req => neighborTerrains.includes(req));
      if (!hasAllRequired) return false;
    }

    const tooClose = this.placedLocations.some(p => Math.abs(x - p.x) + Math.abs(y - p.y) < 3);
    if (tooClose) return false;

    return true;
  }

  async autoGenerate_old() {
    if (this.isGenerating) return;

    // Generate name ‚Üí use as seed
    this.mapName = MapNamer.generate(this);
    const seedValue = MapNamer.stringToSeed(this.mapName);
    Math.seedrandom?.(seedValue); // Requires seedrandom.js

    this.isGenerating = true;
    this.init();
    TemplatePlacer.applyTo(this);

    let attempts = 0;
    const max = this.width * this.height * 2;
    while (!this.isComplete() && attempts < max && this.isGenerating) {
      if (!this.step()) {
        this.log("Restarting...");
        this.init();
        TemplatePlacer.applyTo(this);
        attempts = 0;
      } else {
        attempts++;
      }
      await this.sleep(this.autoSpeed);
    }

    if (this.isComplete() && this.isGenerating) {
      this.placeLocations();
      this.mapName = MapNamer.generate(this); // Re-generate after placing locations
      this.log(`üåç Map Name: "${this.mapName}"`);
      this.log("üéâ Complete with locations!");
    }

    this.isGenerating = false;
    this.updateUI();
  }



async autoGenerate() {
  if (this.isGenerating) return;

  // Use manual name if provided, else generate
  //const input = document.getElementById("mapNameInput");
 // const userInput = input?.value.trim(); // Safe access

  // Use manual name if provided, else generate
  //this.mapName = userInput || MapNamer.generate(this);


  const input = document.getElementById("mapNameInput");
const userInput = input?.value.trim();
this.mapName = userInput || MapNamer.generate(this);

  const seedValue = MapNamer.stringToSeed(this.mapName);
  Math.seedrandom?.(seedValue);

  this.isGenerating = true;
  this.init();
  TemplatePlacer.applyTo(this);

  let attempts = 0;
  const max = this.width * this.height * 2;
  while (!this.isComplete() && attempts < max && this.isGenerating) {
    if (!this.step()) {
      this.log("Restarting...");
      this.init();
      TemplatePlacer.applyTo(this);
      attempts = 0;
    } else {
      attempts++;
    }
    await this.sleep(this.autoSpeed);
  }

  if (this.isComplete() && this.isGenerating) {
    this.placeLocations();

    // Now re-generate name *based on final map* (but don't override user input)
    const finalName = MapNamer.generate(this);
    if (!document.getElementById("mapNameInput").value) {
      this.mapName = finalName;
    }
    // Update placeholder only if not overridden
    this.updateMapName();

    this.log(`üåç Final Name: "${finalName}"`);
    this.log("üéâ Complete with locations!");
  }
  this.isGenerating = false;
  this.updateUI();
}





  sleep(ms) {
    return new Promise(r => setTimeout(r, ms));
  }

updateUI() {
  this.renderGrid();
  this.updateProgress();
  this.updateStats();
  this.updateMapName();

  // üé® Only apply watercolor splotch effect when map is fully generated
  if (this.isComplete()) {
    softRenderer?.update();
  }
}

  renderGrid() {
    const container = document.getElementById("mapGrid");
    const w = this.width;
    const h = this.height;
    const tileSize = Math.min(48, 600 / Math.max(w, h));
    container.style.cssText = `
      grid-template-columns: repeat(${w}, ${tileSize}px);
      grid-template-rows: repeat(${h}, ${tileSize}px);
      gap: 0;
    `;
    container.innerHTML = "";

    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        const cell = this.grid[y][x];
        const tile = document.createElement("div");
        tile.className = "tile";
        tile.dataset.pos = `${x},${y}`;

        if (cell.collapsed) {
          const theme = ThemeManager.current;
          const visual = theme.elevation[cell.terrain];
          tile.style.backgroundColor = visual?.colors[0] // || "#374151";
          if (cell.location) {
            const locTheme = theme.locations[cell.location.id];
            tile.classList.add("location");
            tile.textContent = locTheme?.emoji || cell.location.emoji;
            tile.title = locTheme?.label || cell.location.name;
          }
        } else {
          tile.style.backgroundColor = "transparent";// "#374151";
        }

        tile.style.width = `${tileSize}px`;
        tile.style.height = `${tileSize}px`;
        container.appendChild(tile);
      }
    }
  }

  updateProgress() {
    const total = this.width * this.height;
    const done = this.grid.flat().filter(c => c.collapsed).length;
    const p = Math.round((done / total) * 100);
    const bar = document.getElementById("progressBar");
    bar.style.width = `${p}%`;
    bar.textContent = `${p}%`;
  }

  updateStats() {
    document.getElementById("stepCount").textContent = this.stepCount;
    document.getElementById("locationCount").textContent = this.locationCount;
    const unCollapsed = this.grid.flat().filter(c => !c.collapsed);
    const entropy = unCollapsed.reduce((sum, c) => sum + c.possibilities.length, 0);
    const collapsed = this.grid.flat().filter(c => c.collapsed).length;
    document.getElementById("entropyCount").textContent = entropy;
    document.getElementById("collapsedCount").textContent = collapsed;
  }

updateMapName() {
  const input = document.getElementById("mapNameInput");
  if (!input) return;

  // Only update placeholder if user hasn't typed anything
  if (!input.value) {
    input.placeholder = this.mapName || "Unnamed World";
  }
}

  log(msg) {
    const log = document.getElementById("log");
    const time = new Date().toLocaleTimeString();
    log.innerHTML += `<div>[${time}] ${msg}</div>`;
    log.scrollTop = log.scrollHeight;
  }
}

==================================================
FILE: themes\cyberpunk.json
MODIFIED: 2025-09-05 13:06:37
TOKENS: [92m920[0m
==================================================

{
  "name": "Cyberpunk",
  "description": "A courier navigating zones of privilege and shadow",
  "elevation": {
    "spire": {
      "label": "Corporate Hi-Rise",
      "colors": ["#777", "#1A1A3F", "#2A2A5F"],
      "weight": 10,
      "adjacent": ["enclave", "wasteland"]
    },
    "enclave": {
      "label": "Gated Enclaves",
      "colors": ["#16A34A", "#374151", "#4B5563"],
      "weight": 15,
      "adjacent": ["enclave", "core", "spire"]
    },
    "core": {
      "label": "The City",
      "colors": ["#467fa1", "#2A2A3A", "#3A3A4A"],
      "weight": 30,
      "adjacent": ["core", "canal", "enclave", "wasteland"]
    },
    "canal": {
      "label": "The Slums",
      "colors": ["#54295c", "#33F0FF", "#66F9FF"],
      "weight": 18,
      "adjacent": ["canal", "core", "wasteland"]
    },
    "wasteland": {
      "label": "The Wasteland",
      "colors": ["#7C2D12", "#9A3412", "#C2410C"],
      "weight": 8,
      "adjacent": ["wasteland", "core", "canal"]
    }
  },
  "locations": {
    "safehouse": { "label": "Safehouse", "emoji": "üîê", "rules": { "on": ["core"], "adjacent": ["wasteland"] } },
    "neotower": { "label": "Neo-Tower", "emoji": "üóº", "rules": { "on": ["spire"] } },
    "hub": { "label": "Central Hub", "emoji": "üìç", "rules": { "on": ["core"], "adjacent": ["enclave"] } },
    "forge": { "label": "Tech Forge", "emoji": "üîß", "rules": { "on": ["wasteland"], "adjacent": ["canal"] } },
    "sanctum": { "label": "Data Sanctum", "emoji": "üíæ", "rules": { "on": ["spire"], "adjacent": ["enclave"] } },
    "junction": { "label": "Net Junction", "emoji": "üåê", "rules": { "on": ["core"], "adjacent": ["canal", "wasteland"] } },
    "slumlord": { "label": "Slum Lord's Den", "emoji": "üíÄ", "rules": { "on": ["wasteland"] } },
    "vault": { "label": "Neural Vault", "emoji": "üß†", "rules": { "on": ["wasteland"], "adjacent": ["canal"] } },
    "beacon": { "label": "Signal Beacon", "emoji": "üì°", "rules": { "on": ["spire"], "adjacent": ["core"] } },
    "clinic": { "label": "Bio-Clinic", "emoji": "üíâ", "rules": { "on": ["core"], "adjacent": ["enclave"] } }
  },
  "templates": {
    "data_river": {
      "weight": 4,
      "placement": "any",
      "pattern": [
        ["core", "canal", "core"],
        ["core", "canal", "core"],
        ["wasteland", "canal", "enclave"]
      ]
    },
    "spire_fortress": {
      "weight": 2,
      "placement": "center",
      "pattern": [
        ["spire", "spire", "spire"],
        ["spire", "spire", "spire"],
        ["enclave", "enclave", "wasteland"]
      ]
    }
  }
}

==================================================
FILE: themes\fantasy.json
MODIFIED: 2025-09-05 12:34:21
TOKENS: [92m946[0m
==================================================

{
  "name": "Fantasy",
  "description": "A quiet journey through enchanted lands",
  "elevation": {
    "spire": {
      "label": "Ancient Peaks",
      "colors": ["#777", "#4B5563", "#6B7280"],
      "weight": 12,
      "adjacent": ["forest", "barrens"]
    },
    "forest": {
      "label": "Whispering Woods",
      "colors": ["#16A34A", "#15803D", "#166534"],
      "weight": 30,
      "adjacent": ["forest", "meadow", "spire"]
    },
    "meadow": {
      "label": "Sunlit Glades",
      "colors": ["#A3E635", "#84CC16", "#65A30D"],
      "weight": 20,
      "adjacent": ["meadow", "forest", "water"]
    },
    "water": {
      "label": "Glass Rivers",
      "colors": ["#1D4ED8", "#2563EB", "#3B82F6"],
      "weight": 18,
      "adjacent": ["water", "meadow", "barrens"]
    },
    "barrens": {
      "label": "Cursed Lands",
      "colors": ["#7C2D12", "#9A3412", "#C2410C"],
      "weight": 5,
      "adjacent": ["spire", "forest", "barrens"]
    }
  },
  "locations": {
    "cottage": { "label": "Hermit's Cottage", "emoji": "üõñ", "rules": { "on": ["forest"], "adjacent": ["water"] } },
    "peak": { "label": "Dragon's Perch", "emoji": "üêâ", "rules": { "on": ["spire"] } },
    "sanctum": { "label": "Crystal Sanctum", "emoji": "üîÆ", "rules": { "on": ["spire"], "adjacent": ["barrens"] } },
    "ruins": { "label": "Fallen Temple", "emoji": "üèõÔ∏è", "rules": { "on": ["barrens"], "adjacent": ["spire"] } },
    "lighthouse": { "label": "Lantern Tower", "emoji": "üóº", "rules": { "on": ["meadow"], "adjacent": ["water"] } },
    "wharf": { "label": "River Wharf", "emoji": "‚öì", "rules": { "on": ["meadow", "water"], "adjacent": ["forest"] } },
    "crossroads": { "label": "Fae Crossroads", "emoji": "üõ£Ô∏è", "rules": { "on": ["forest"], "adjacent": ["meadow", "spire"] } },
    "mines": { "label": "Gem Caverns", "emoji": "üíé", "rules": { "on": ["spire"], "adjacent": ["barrens"] } },
    "grove": { "label": "Sacred Grove", "emoji": "üå≥", "rules": { "on": ["forest"] } },
    "ford": { "label": "Stone Ford", "emoji": "ü™®", "rules": { "on": ["water"], "adjacent": ["meadow"] } }
  },
  "templates": {
    "river_flow": {
      "weight": 4,
      "placement": "any",
      "pattern": [
        [null, "meadow", "water", "meadow", null],
        [null, "meadow", "water", "meadow", null],
        ["forest", "forest", "water", "forest", "forest"],
        ["forest", "forest", "water", "forest", "forest"],
        [null, "meadow", "water", "meadow", null]
      ]
    },
    "mountain_heart": {
      "weight": 2,
      "placement": "center",
      "pattern": [
        ["spire", "spire", "spire"],
        ["spire", "spire", "spire"],
        ["forest", "forest", "barrens"]
      ]
    }
  }
}

==================================================
FILE: themes\modern.json
MODIFIED: 2025-09-05 12:58:06
TOKENS: [92m892[0m
==================================================

{
  "name": "Modern",
  "description": "A courier biking through city rhythms and quiet corners",
  "elevation": {
    "estates": {
      "label": "Hillside Estates",
      "colors": ["#10B981", "#6B7280", "#4B5563"],
      "weight": 12,
      "adjacent": ["suburbia", "tracks"]
    },
    "suburbia": {
      "label": "Tree-Lined Suburbia",
      "colors": ["#16A34A", "#F3F4F6", "#E5E7EB"],
      "weight": 25,
      "adjacent": ["suburbia", "downtown", "estates"]
    },
    "downtown": {
      "label": "Downtown Blocks",
      "colors": ["#9CA3AF", "#059669", "#047857"],
      "weight": 30,
      "adjacent": ["downtown", "river", "suburbia", "tracks"]
    },
    "river": {
      "label": "Riverside Path",
      "colors": ["#0EA5E9", "#0284C7", "#0369A1"],
      "weight": 18,
      "adjacent": ["river", "downtown", "tracks"]
    },
    "tracks": {
      "label": "Wrong Side of Tracks",
      "colors": ["#374151", "#1F2937", "#111827"],
      "weight": 8,
      "adjacent": ["tracks", "downtown", "river"]
    }
  },
  "locations": {
    "shed": { "label": "Garden Shed", "emoji": "üè°", "rules": { "on": ["downtown"], "adjacent": ["river"] } },
    "observatory": { "label": "Hilltop Observatory", "emoji": "üî≠", "rules": { "on": ["estates"] } },
    "square": { "label": "Town Square", "emoji": "üìç", "rules": { "on": ["downtown"], "adjacent": ["suburbia"] } },
    "shop": { "label": "Repair Shop", "emoji": "üîß", "rules": { "on": ["tracks"], "adjacent": ["river"] } },
    "garden": { "label": "Community Garden", "emoji": "üå±", "rules": { "on": ["downtown"], "adjacent": ["river"] } },
    "circle": { "label": "Traffic Circle", "emoji": "üö¶", "rules": { "on": ["downtown"], "adjacent": ["suburbia"] } },
    "lot": { "label": "Abandoned Lot", "emoji": "üöß", "rules": { "on": ["tracks"] } },
    "warehouse": { "label": "Distribution Hub", "emoji": "üì¶", "rules": { "on": ["tracks"], "adjacent": ["river"] } },
    "bridge": { "label": "Rail Bridge", "emoji": "üåâ", "rules": { "on": ["river"], "adjacent": ["tracks"] } },
    "cafe": { "label": "Corner Cafe", "emoji": "‚òï", "rules": { "on": ["downtown"], "adjacent": ["suburbia"] } }
  },
  "templates": {
    "riverside_path": {
      "weight": 4,
      "placement": "any",
      "pattern": [
        ["downtown", "river", "downtown"],
        ["downtown", "river", "downtown"],
        ["tracks", "river", "suburbia"]
      ]
    },
    "hillside_view": {
      "weight": 2,
      "placement": "center",
      "pattern": [
        ["estates", "estates", "estates"],
        ["estates", "estates", "estates"],
        ["suburbia", "suburbia", "tracks"]
      ]
    }
  }
}

