All files from 'WaveFunctionCollapse'
Generated: 2025-09-06 01:27:44
Mode: all
Included extensions: png, jsx, txt, jpeg, svg, toml, sass, tsx, py, bmp, gif, ts, json, html, jpg, webp, css, ini, scss, cfg, yaml, yml, tiff, less, vue, js
Tiktoken available: True
Encoding: cl100k_base
==================================================

==================================================
FILE: index.html
MODIFIED: 2025-09-06 00:41:53
TOKENS: [92m1,093[0m
==================================================

<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Wave Function Collapse - Smart Location Placement</title>
        <link rel="stylesheet" href="css/style.css" />
    </head>
    <body>
        <div class="container">
            <!-- Header -->
            <header class="header">
                <h1>Wave Function Collapse Map</h1>
                <p>Smart Locations + Data-Driven Terrain</p>
            </header>

            <!-- Controls -->

            <div class="controls">
                <!-- Map Name and Generate Buttons -->
                <div class="top-controls">
                    <div class="map-name-group">
                        <!-- <label for="mapNameInput">Map Name</label> -->
                        <div class="input-with-copy">
                            <input type="text" id="mapNameInput" class="input-text" placeholder="A Mysterious Place" />
                            <button id="copyMapNameBtn" title="Copy map name" aria-label="Copy name">üìã</button>
                        </div>
                    </div>

                    <div class="button-group">
                        <button id="generateBtn">Generate New World</button>
                        <button id="stepBtn">Step Forward</button>
                        <button id="autoBtn">Auto Generate</button>
                        <button id="resetBtn">Reset</button>
                    </div>
                </div>

                <!-- Grid Size moved to sidebar -->
            </div>

            <!-- Main Content -->
            <div class="main-content">
                <!-- With this: -->
                <div class="map-area">
                    <canvas id="parchmentCanvas" class="overlay-canvas"></canvas>
                    <canvas id="watercolorCanvas" class="overlay-canvas"></canvas>
                    <div id="mapGrid" class="map-grid"></div>
                </div>

                <aside class="sidebar">
                    <div class="info-section">
                        <h3>Theme</h3>
                        <select id="themeSelect">
                            <option value="fantasy">üè∞ Fantasy</option>
                            <option value="cyberpunk">üåÉ Cyberpunk</option>
                            <option value="modern">üö≤ Modern</option>
                        </select>
                    </div>

                    <div class="info-section">
                        <h3>Grid Size</h3>
                        <div class="grid-size">
                            <input type="number" id="gridWidth" value="8" min="4" max="24" />
                            <span>√ó</span>
                            <input type="number" id="gridHeight" value="8" min="4" max="24" />
                        </div>
                    </div>

                    <div class="info-section">
                        <h3>Progress</h3>
                        <div class="progress-bar-container">
                            <div id="progressBar" class="progress-bar">0%</div>
                        </div>
                        <div class="speed-controls">
                            <button id="slowBtn">Slow</button>
                            <button id="normalBtn">Normal</button>
                            <button id="fastBtn">Fast</button>
                        </div>
                    </div>

                    <div class="info-section">
                        <h3>Terrain Legend</h3>
                        <div id="legend" class="legend"></div>
                    </div>

                    <div class="info-section">
                        <h3>Statistics</h3>
                        <div class="stats">
                            <div class="stat"><span>Steps:</span> <span id="stepCount">0</span></div>
                            <div class="stat"><span>Locations:</span> <span id="locationCount">0</span></div>
                            <div class="stat"><span>Entropy:</span> <span id="entropyCount">0</span></div>
                            <div class="stat"><span>Collapsed:</span> <span id="collapsedCount">0</span></div>
                        </div>
                    </div>

                    <div class="info-section">
                        <h3>Log</h3>
                        <div id="log" class="log"></div>
                    </div>
                </aside>
            </div>
        </div>

        <!-- Scripts -->
        <script async src="https://stats.ill13.com/script.js" data-website-id="acd6458a-bc5c-4a87-92a2-4ca46d461135"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/seedrandom/3.0.5/seedrandom.min.js"></script>
        <script src="js/loader.js"></script>
        <script src="js/themeManager.js"></script>
        <script src="js/classes/MapNamer.js"></script>
        <script src="js/classes/WaveFunctionCollapse.js"></script>
        <script src="js/classes/WatercolorOverlay.js"></script>
        <script src="js/TemplatePlacer.js"></script>
        <script src="js/main.js"></script>
    </body>
</html>


==================================================
FILE: wc.html
MODIFIED: 2025-09-06 00:16:27
TOKENS: [92m1,775[0m
==================================================

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Watercolor Map Overlay - Vanilla JS</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #eee;
      font-family: 'Consolas', monospace;
    }
    canvas {
      display: block;
      background: #f0f0f0;
    }
    .controls {
      position: absolute;
      top: 10px;
      left: 10px;
      padding: 10px;
      background: rgba(255,255,255,0.9);
      border-radius: 6px;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
    }
    .palette {
      display: flex;
      gap: 8px;
      margin-top: 10px;
    }
    .color-swatch {
      width: 30px;
      height: 30px;
      border-radius: 4px;
      cursor: pointer;
      transition: transform 0.1s ease;
    }
    .color-swatch:hover {
      transform: scale(1.1);
    }
    .color-swatch.active {
      border: 2px solid #000;
      transform: scale(1.1);
    }
  </style>
</head>
<body>

  <div class="controls">
    <h3>Colors</h3>
    <div class="palette" id="palette"></div>
  </div>

  <canvas id="canvas"></canvas>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const paletteEl = document.getElementById('palette');

    // Set canvas size
    function resizeCanvas() {
      canvas.width = window.innerWidth * 0.9;
      canvas.height = window.innerHeight * 0.8;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Fantasy theme colors (from fantasy.json)
    const FANTASY_COLORS = [
      { name: "Forest", hex: "#16A34A" },
      { name: "Meadow", hex: "#A3E635" },
      { name: "Water", hex: "#1D4ED8" },
      { name: "Barrens", hex: "#C2410C" },
      { name: "Spire", hex: "#777" }
    ];

    // Initialize color palette
    FANTASY_COLORS.forEach(color => {
      const swatch = document.createElement('div');
      swatch.className = 'color-swatch';
      swatch.style.backgroundColor = color.hex;
      swatch.dataset.hex = color.hex;
      swatch.title = color.name;
      swatch.addEventListener('click', () => {
        selectedColor = color.hex;
        swatch.classList.add('active');
        document.querySelectorAll('.color-swatch').forEach(el => {
          if (el !== swatch) el.classList.remove('active');
        });
      });
      paletteEl.appendChild(swatch);
    });

    let selectedColor = FANTASY_COLORS[0].hex;

    // Draw parchment texture (base layer)
    function drawParchmentTexture() {
      const w = canvas.width;
      const h = canvas.height;
      const imageData = ctx.createImageData(w, h);
      for (let i = 0; i < imageData.data.length; i += 4) {
        const value = 245 + Math.random() * 10;
        const tint = Math.random() > 0.9 ? 10 : 0;
        imageData.data[i] = value + tint; // R
        imageData.data[i + 1] = value - 10 + tint; // G
        imageData.data[i + 2] = value - 30; // B
        imageData.data[i + 3] = 255; // A
      }
      ctx.putImageData(imageData, 0, 0);

      // Lighten base with screen blend
      ctx.globalCompositeOperation = "screen";
      ctx.fillStyle = "rgba(255, 255, 220, 0.1)";
      ctx.fillRect(0, 0, w, h);
      ctx.globalCompositeOperation = "source-over"; // Reset
    }

    // Draw grain (paper texture)
    function drawGrain(cx, cy, size, color, alpha) {
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.fillStyle = color;
      for (let i = 0; i < 6; i++) {
        const rx = cx - size / 2 + Math.random() * size;
        const ry = cy - size / 2 + Math.random() * size;
        ctx.fillRect(rx, ry, 1, 1);
      }
      ctx.restore();
    }

    // Draw fluffy blob (soft, blurred-like effect)
    function drawFluffyBlob(x, y, rgb, size = 40) {
      ctx.save();
      const angle = Math.random() * Math.PI * 2;
      ctx.translate(x, y);
      ctx.rotate(angle);

      const numLayers = 8;
      const maxRadius = size * 1.2;

      for (let i = 0; i < numLayers; i++) {
        const r = maxRadius * (i / numLayers);
        const opacity = 0.15 - (i * 0.015); // Fade out
        const jitterX = Math.random() * 15 - 7.5;
        const jitterY = Math.random() * 15 - 7.5;

        const some_num = 10
        ctx.fillStyle = `rgba(${rgb.r + noise(-some_num,some_num)}, ${rgb.g + noise(-some_num,some_num)}, ${rgb.b + noise(-some_num,some_num)}, ${opacity})`;

        ctx.beginPath();
        ctx.arc(jitterX, jitterY, r, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.restore();
    }

    // Helper: random with range
    function noise(min, max) {
      return Math.random() * (max - min) + min;
    }

    // Convert hex to RGB
    function hexToRgb(hex) {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      return { r, g, b };
    }

    // Mouse interaction
    let isDrawing = false;
    let lastX, lastY;

    canvas.addEventListener('mousedown', startDrawing);
    canvas.addEventListener('mousemove', draw);
    canvas.addEventListener('mouseup', stopDrawing);
    canvas.addEventListener('mouseleave', stopDrawing);

    function startDrawing(e) {
      isDrawing = true;
      [lastX, lastY] = [e.offsetX, e.offsetY];
    }

    function draw(e) {
      if (!isDrawing) return;

      const x = e.offsetX;
      const y = e.offsetY;

      // Only draw every 100ms
      if (Date.now() - lastDrawTime < 50) return;
      lastDrawTime = Date.now();

      const rgb = hexToRgb(selectedColor);
      drawFluffyBlob(x, y, rgb, 25);
    }

    function stopDrawing() {
      isDrawing = false;
    }

    // Initial setup
    let lastDrawTime = 0;

    // Draw parchment background once
    drawParchmentTexture();

    // Add grain texture (optional)
    for (let i = 0; i < 100; i++) {
      const x = Math.random() * canvas.width;
      const y = Math.random() * canvas.height;
      drawGrain(x, y, 10, '#333', 0.05);
    }

    // Optional: Add subtle vignette
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,0.05)';
    ctx.beginPath();
    ctx.arc(canvas.width / 2, canvas.height / 2, canvas.width * 0.8, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  </script>

</body>
</html>

==================================================
FILE: css\style.css
MODIFIED: 2025-09-06 01:08:46
TOKENS: [92m2,117[0m
==================================================

/* === Global Styles === */
:root {
  --bg-primary: linear-gradient(135deg, #1a2a1a, #2d3d20);
  --bg-panel: #3a2818;
  --border-primary: #5d4037;
  --border-accent: #d4af37;
  --text-primary: #e8dcc5;
  --text-gold: #d4af37;
  --padding: 16px;
  --border-radius: 6px;
  --shadow: 0 0 20px rgba(0, 0, 0, 0.5), inset 0 0 0 2px rgba(212, 175, 55, 0.2);
}

* {
  box-sizing: border-box;
}

body {
  margin: 0;
  padding: 8px;
  font-family: 'Consolas', monospace;
  background: var(--bg-primary);
  color: var(--text-primary);
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

.container {
  max-width: 1200px;
  margin: 0 auto;
  width: 100%;
}

/* === Header === */
.header {
  text-align: center;
  margin-bottom: 20px;
  padding: 20px;
  background: var(--bg-panel);
  border: 1px solid var(--border-accent);
  border-radius: var(--border-radius);
  color: var(--text-gold);
}

.header h1 {
  margin: 0;
  font-size: 2rem;
  letter-spacing: 1px;
}

.header p {
  margin: 8px 0 0;
  font-size: 0.9rem;
  opacity: 0.8;
}

/* === Controls === */
.controls {
  display: flex;
  flex-direction: column;
  gap: 16px;
  padding: 16px;
  background: var(--bg-panel);
  border: 1px solid var(--border-primary);
  border-radius: var(--border-radius);
  margin-bottom: 16px;
}

.top-controls {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  gap: 16px;
  flex-wrap: wrap;
}


.map-name-group {
  min-width: 200px;
  display: flex;
  flex-direction: column;
  gap: 8px;
  flex-shrink: 0; /* Prevents horizontal stretching */
}

.map-name-group label {
  font-size: 0.9rem;
  color: var(--text-gold);
  margin: 0;
}

.map-name-group .input-text,
.grid-size input[type="number"] {
  padding: 8px 12px;
  background: rgba(0, 0, 0, 0.3);
  border: 1px solid var(--border-primary);
  color: var(--text-primary);
  border-radius: 4px;
  font-family: 'Consolas', monospace;
  font-size: 14px;
  outline: none;
}

.map-name-group .input-text:focus {
  border-color: var(--text-gold);
  box-shadow: 0 0 0 2px rgba(212, 175, 55, 0.2);
}

.map-name-group .input-with-copy {
  display: flex;
  align-items: center;
  gap: 8px;
  width: 100%;
}

.map-name-group button {
  margin: 0;
  padding: 6px 12px;
  font-size: 12px;
  background: var(--border-accent);
  color: var(--bg-panel);
  border: none;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.map-name-group button:hover {
  background: #f0c855;
  transform: translateY(-1px);
}

.button-group {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  flex: 1;
  margin-top: 0;
  align-self: flex-start;
}

.button-group button {
  padding: 10px 16px;
  background: var(--bg-panel);
  color: var(--text-gold);
  border: 1px solid var(--border-accent);
  border-radius: 4px;
  font-family: 'Consolas', monospace;
  font-size: 14px;
  cursor: pointer;
  transition: all 0.2s ease;
  margin: 0;
}

.button-group button:hover {
  background: #4a3a2a;
}

button:active {
  transform: scale(0.98);
}

/* === Main Content === */
.main-content {
  display: flex;
  flex-direction: column;
  gap: 16px;
}

@media (min-width: 768px) {
  .main-content {
    flex-direction: row;
  }
}

.map-area {
  flex: 1;
  background: #1a2a1a;
  border: 2px solid var(--border-accent);
  border-radius: var(--border-radius);
  box-shadow: var(--shadow);
  position: relative;
  min-height: 400px;
  display: flex;
  justify-content: center;
  align-items: center;
  overflow: hidden;
}

.map-grid {
  display: grid;
  gap: 0;
  border: none;
}

.tile {
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  transition: all 0.2s ease;
  height: 100%;
  width: 100%;
}

.tile.location {
  z-index: 2;
  scale: 100%;
}

.tile.uncollapsed {
  background: #374151;
  color: transparent;
}

/* === Sidebar === */
.sidebar {
  flex: 0 0 300px;
  background: var(--bg-panel);
  border: 1px solid var(--border-primary);
  border-radius: var(--border-radius);
  padding: var(--padding);
  color: var(--text-primary);
}

.info-section {
  margin-bottom: 16px;
}

.info-section h3 {
  margin: 0 0 10px;
  color: var(--text-gold);
  font-size: 1.1rem;
}

.grid-size {
  display: flex;
  align-items: center;
  gap: 4px;
  font-size: 14px;
}

.grid-size input[type="number"] {
  width: 60px;
  padding: 6px;
  text-align: center;
}

/* === Progress Bar === */
.progress-bar-container {
  width: 100%;
  height: 20px;
  background: #2a2a2a;
  border-radius: 4px;
  overflow: hidden;
  margin: 10px 0;
}

.progress-bar {
  height: 100%;
  background: var(--border-accent);
  transition: width 0.3s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  color: #000;
}

/* === Speed Controls === */
.speed-controls {
  display: flex;
  gap: 8px;
  margin-top: 10px;
}

.speed-controls button {
  flex: 1;
  padding: 6px;
  font-size: 12px;
}

/* === Legend === */
.legend {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
  gap: 8px;
  font-size: 12px;
}

.legend-item {
  display: flex;
  align-items: center;
  gap: 6px;
}

.legend-tile {
  width: 16px;
  height: 16px;
  border-radius: 2px;
}

/* === Stats === */
.stats {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px;
  font-size: 12px;
}

.stat {
  text-align: center;
  padding: 8px;
  background: rgba(0,0,0,0.3);
  border-radius: 4px;
}

.stat span:first-child {
  font-size: 0.8rem;
  opacity: 0.7;
}

/* === Log === */
.log {
  background: rgba(0,0,0,0.5);
  padding: 10px;
  border-radius: 4px;
  max-height: 150px;
  overflow-y: auto;
  font-size: 11px;
  line-height: 1.4;
}

/* === Responsive === */
@media (max-width: 767px) {
  .top-controls {
    flex-direction: column;
    align-items: stretch;
  }

  .map-name-group,
  .button-group {
    width: 100%;
  }

  .controls {
    padding: 12px;
  }

  .button-group {
    flex-direction: column;
  }

  .map-area {
    min-height: 300px;
  }

  .sidebar {
    flex: 1;
    order: 2;
  }

  .main-content {
    flex-direction: column;
  }
}

/* === Watercolor Overlay Canvases === */
.overlay-canvas {
  position: absolute;
  top: 0;
  left: 0;
  z-index: 1;
  pointer-events: none;
  image-rendering: -webkit-optimize-contrast;
  image-rendering: crisp-edges;
}

#parchmentCanvas {
  z-index: 1;
}

#watercolorCanvas {
  z-index: 2;
}

#mapGrid {
  position: relative;
  z-index: 3; /* On top for locations */
  background: transparent;
}

==================================================
FILE: js\loader.js
MODIFIED: 2025-09-04 15:33:54
TOKENS: [92m179[0m
==================================================

// js/loader.js
class DataLoader {
  static async loadTheme(themeName) {
    const res = await fetch(`themes/${themeName}.json`);
    const theme = await res.json();

    // Extract terrain rules and weights
    const TERRAIN_TYPES = {};
    Object.keys(theme.elevation).forEach((type) => {
      TERRAIN_TYPES[type] = {
        weight: theme.elevation[type].weight || 1,
        adjacent: theme.elevation[type].adjacent || [],
        colors: theme.elevation[type].colors || ["#333"],
      };
    });

    const LOCATIONS = Object.entries(theme.locations).map(([id, loc]) => ({
      id,
      ...loc,
    }));
    const TEMPLATES = theme.templates || {};

    return { TERRAIN_TYPES, LOCATIONS, TEMPLATES, THEME: theme };
  }
}


==================================================
FILE: js\main.js
MODIFIED: 2025-09-06 01:23:38
TOKENS: [92m1,144[0m
==================================================

// js/main.js
let TERRAIN_TYPES, LOCATIONS;
let wfc;
let watercolorOverlay = null;

async function initApp() {
    const themeName = document.getElementById("themeSelect").value;
    const data = await DataLoader.loadTheme(themeName);
    TERRAIN_TYPES = data.TERRAIN_TYPES;
    LOCATIONS = data.LOCATIONS;
    ThemeManager.setTheme(themeName);

    const width = parseInt(document.getElementById("gridWidth").value);
    const height = parseInt(document.getElementById("gridHeight").value);
    wfc = new WaveFunctionCollapse(width, height, themeName);
    const mapArea = document.querySelector(".map-area");
    const tileSize = Math.min(48, 600 / Math.max(wfc.width, height));
    watercolorOverlay = new WatercolorOverlay(mapArea, wfc.width, wfc.height, tileSize, MapNamer.stringToSeed(wfc.mapName));

    updateLegend();
    setupEventListeners();
    wfc.updateUI();
}

function updateLegend() {
    const legendEl = document.getElementById("legend");
    legendEl.innerHTML = "";
    const theme = ThemeManager.current;
    Object.keys(theme.elevation).forEach((type) => {
        const visual = theme.elevation[type];
        const item = document.createElement("div");
        item.className = "legend-item";
        const tile = document.createElement("div");
        tile.className = "legend-tile";
        tile.style.backgroundColor = visual.colors[0];
        const label = document.createElement("span");
        label.textContent = visual.label;
        item.appendChild(tile);
        item.appendChild(label);
        legendEl.appendChild(item);
    });
}

function setupEventListeners() {
    // Copy Map Name Button
    document.getElementById("copyMapNameBtn").addEventListener("click", () => {
        const input = document.getElementById("mapNameInput");
        const text = input.value || input.placeholder;

        navigator.clipboard
            .writeText(text)
            .then(() => {
                const btn = document.getElementById("copyMapNameBtn");
                const original = btn.textContent;
                btn.textContent = "‚úÖ Copied!";
                setTimeout(() => (btn.textContent = original), 2000);
            })
            .catch((err) => {
                console.warn("Copy failed:", err);
                alert("Could not copy to clipboard: " + err);
            });
    });

    document.getElementById("generateBtn").addEventListener("click", () => {
        const w = parseInt(document.getElementById("gridWidth").value);
        const h = parseInt(document.getElementById("gridHeight").value);
        const themeName = document.getElementById("themeSelect").value;
        // Clear old overlay
        if (window.watercolorOverlay) {
            window.watercolorOverlay.clear();
        }
        wfc = new WaveFunctionCollapse(w, h, themeName);

        // Then create new one after wfc
        const mapArea = document.querySelector(".map-area");
        const tileSize = Math.min(48, 600 / Math.max(w, h));
        const seed = MapNamer.stringToSeed(wfc.mapName);
        window.watercolorOverlay = new WatercolorOverlay(mapArea, w, h, tileSize, seed);

        wfc.autoGenerate();
    });

    document.getElementById("stepBtn").addEventListener("click", () => {
        if (!wfc.isGenerating) wfc.step();
    });

    document.getElementById("autoBtn").addEventListener("click", () => {
        const btn = document.getElementById("autoBtn");
        if (wfc.isGenerating) {
            wfc.isGenerating = false;
            btn.textContent = "Auto Generate";
        } else {
            btn.textContent = "Auto Step";
            wfc.autoGenerate();
        }
    });

    document.getElementById("resetBtn").addEventListener("click", () => {
        const w = parseInt(document.getElementById("gridWidth").value);
        const h = parseInt(document.getElementById("gridHeight").value);
        const themeName = document.getElementById("themeSelect").value;
        // Clear old overlay
        if (window.watercolorOverlay) {
            window.watercolorOverlay.clear();
        }
        wfc = new WaveFunctionCollapse(w, h, themeName);
        // Then create new one after wfc
        const mapArea = document.querySelector(".map-area");
        const tileSize = Math.min(48, 600 / Math.max(w, h));
        const seed = MapNamer.stringToSeed(wfc.mapName);
        window.watercolorOverlay = new WatercolorOverlay(mapArea, w, h, tileSize, seed);

        document.getElementById("autoBtn").textContent = "Auto Generate";
    });

    document.getElementById("slowBtn").addEventListener("click", () => (wfc.autoSpeed = 300));
    document.getElementById("normalBtn").addEventListener("click", () => (wfc.autoSpeed = 100));
    document.getElementById("fastBtn").addEventListener("click", () => (wfc.autoSpeed = 30));

    document.getElementById("themeSelect").addEventListener("change", async () => {
        const themeName = document.getElementById("themeSelect").value;
        const data = await DataLoader.loadTheme(themeName);
        TERRAIN_TYPES = data.TERRAIN_TYPES;
        LOCATIONS = data.LOCATIONS;
        ThemeManager.setTheme(themeName);
        const w = parseInt(document.getElementById("gridWidth").value);
        const h = parseInt(document.getElementById("gridHeight").value);
        wfc = new WaveFunctionCollapse(w, h, themeName);
        wfc.updateUI();
    });
}

// Start
document.addEventListener("DOMContentLoaded", async () => {
    await ThemeManager.loadThemes();
    initApp();
});


==================================================
FILE: js\TemplatePlacer.js
MODIFIED: 2025-09-04 15:17:15
TOKENS: [92m643[0m
==================================================

// js/TemplatePlacer.js
class TemplatePlacer {
    static applyTo(wfc, templates) {
        if (!templates || Object.keys(templates).length === 0) return;

        const templateList = Object.entries(templates).map(([id, t]) => ({ id, ...t }));

        const numToApply = Math.floor(Math.random() * 2) + 1;
        for (let i = 0; i < numToApply; i++) {
            if (templateList.length === 0) break;
            const template = this.getRandomTemplate(templateList);
            const applied = this.applyTemplateToGrid(template, wfc.grid, wfc.width, wfc.height);
            if (applied) {
                wfc.log(`üé® Applied template: ${template.id}`);
            }
        }
    }

    static getRandomTemplate(templates) {
        const totalWeight = templates.reduce((sum, t) => sum + t.weight, 0);
        let r = Math.random() * totalWeight;
        for (const template of templates) {
            r -= template.weight;
            if (r <= 0) return template;
        }
        return templates[0];
    }

    static getPlacementPosition(template, width, height) {
        const tWidth = template.pattern[0]?.length || 0;
        const tHeight = template.pattern.length || 0;
        if (tWidth === 0 || tHeight === 0) return { x: 0, y: 0 };

        let x, y;
        switch (template.placement) {
            case "center":
                x = Math.floor((width - tWidth) / 2);
                y = Math.floor((height - tHeight) / 2);
                break;
            case "top_left":
                x = 0;
                y = 0;
                break;
            default: // "any"
                x = Math.floor(Math.random() * (width - tWidth + 1));
                y = Math.floor(Math.random() * (height - tHeight + 1));
        }
        x = Math.max(0, Math.min(x, width - tWidth));
        y = Math.max(0, Math.min(y, height - tHeight));
        return { x, y };
    }

    static applyTemplateToGrid(template, grid, width, height) {
        const { x: startX, y: startY } = this.getPlacementPosition(template, width, height);
        const pattern = template.pattern;

        for (let dy = 0; dy < pattern.length; dy++) {
            for (let dx = 0; dx < pattern[dy].length; dx++) {
                const x = startX + dx;
                const y = startY + dy;
                const terrainType = pattern[dy][dx];
                if (terrainType === null || terrainType === "") continue;
                const cell = grid[y]?.[x];
                if (!cell) continue;
                cell.possibilities = [terrainType];
                cell.collapsed = false;
            }
        }
        return true;
    }
}

==================================================
FILE: js\themeManager.js
MODIFIED: 2025-09-04 15:27:11
TOKENS: [92m249[0m
==================================================

// js/themeManager.js
class ThemeManager {
    static themes = {};
    static current = null;

    static async loadThemes() {
        const themeFiles = ['fantasy', 'cyberpunk', 'modern'];
        const promises = themeFiles.map(async name => {
            const res = await fetch(`themes/${name}.json`);
            const theme = await res.json();
            this.themes[name] = theme;
        });
        await Promise.all(promises);
        this.current = this.themes.fantasy; // default
    }

    static setTheme(dataOrName) {
    let theme = null;

    if (typeof dataOrName === 'string') {
        theme = this.themes[dataOrName];
        if (!theme) {
            console.warn(`Theme "${dataOrName}" not found`);
            return;
        }
    } else {
        theme = dataOrName;
    }

    this.current = theme;
    window.wfc?.updateUI();
    updateLegend();
}

    // ‚úÖ ADD THIS METHOD BACK
    static getRandomColor(colors) {
        if (!colors || colors.length === 0) return "#333";
        return colors[Math.floor(Math.random() * colors.length)];
    }
}

==================================================
FILE: js\classes\MapNamer.js
MODIFIED: 2025-09-05 13:55:26
TOKENS: [92m1,195[0m
==================================================

// js/classes/MapNamer.js
class MapNamer {
  static generate_old(wfc) {
    const theme = wfc.themeName; // e.g., 'fantasy'

    // Gather data
    const grid = wfc.grid.flat();
    const terrainCount = {};
    const placedLocations = wfc.placedLocations;

    grid.forEach(cell => {
      if (cell.terrain) terrainCount[cell.terrain] = (terrainCount[cell.terrain] || 0) + 1;
    });

    // Dominant terrain
    const dominantTerrain = Object.keys(terrainCount).reduce((a, b) =>
      terrainCount[a] > terrainCount[b] ? a : b
    );

    // Get label from theme
    const themeData = ThemeManager.current;
    const terrainLabel = themeData.elevation[dominantTerrain]?.label || "Unknown";

    // Iconic location (rarest or most special)
    const iconicLocation = placedLocations.length > 0
      ? placedLocations.sort((a, b) => {
        const aWeight = TERRAIN_TYPES[a.loc.id]?.weight || 1;
        const bWeight = TERRAIN_TYPES[b.loc.id]?.weight || 1;
        return aWeight - bWeight; // lower weight = rarer
      })[0]?.loc.name
      : null;

    // Adjectives by theme
    const adjectives = {
      fantasy: ["Sacred", "Ancient", "Whispering", "Cursed", "Hidden", "Eternal", "Forgotten"],
      cyberpunk: ["Abandoned", "Neon", "Fractured", "Silent", "Bleeding", "Data-Lit", "Fallen"],
      modern: ["Quiet", "Tree-Lined", "Busy", "Riverside", "Hillside", "Empty", "Sunlit"]
    };

    const adj = adjectives[theme] ? adjectives[theme][Math.floor(Math.random() * adjectives[theme].length)] : "Mysterious";

    // Name patterns
    const patterns = [
      `${adj} ${terrainLabel}`,
      `${iconicLocation ? iconicLocation : `The ${adj} Site`} in the ${terrainLabel}`,
      `${iconicLocation ? `${iconicLocation} of` : `The ${adj} Realm of`} the ${terrainLabel}`,
      `The ${adj} ${iconicLocation || "Place"} by the ${terrainLabel}`,
      `Where the ${terrainLabel} Begins`
    ];

    return patterns[Math.floor(Math.random() * patterns.length)];
  }




static generate(wfc) {
  const theme = wfc.themeName;
  const grid = wfc.grid.flat();

  // Count terrain types
  const terrainCount = {};
  grid.forEach(cell => {
    if (cell.terrain) terrainCount[cell.terrain] = (terrainCount[cell.terrain] || 0) + 1;
  });

  // Get dominant terrain with fallback
  let dominantTerrain;
  const terrainKeys = Object.keys(terrainCount);
  if (terrainKeys.length > 0) {
    dominantTerrain = terrainKeys.reduce((a, b) =>
      terrainCount[a] > terrainCount[b] ? a : b
    );
  } else {
    // Fallback: use the first terrain type from TERRAIN_TYPES
    dominantTerrain = Object.keys(TERRAIN_TYPES)[0] || "meadow"; // generic fallback
  }

  // Get label from theme
  const themeData = ThemeManager.current;
  const terrainLabel = themeData.elevation[dominantTerrain]?.label || "Unknown";

  // Iconic location (rarest or most special)
  const iconicLocation = wfc.placedLocations.length > 0
    ? wfc.placedLocations.sort((a, b) => {
        const aWeight = TERRAIN_TYPES[a.loc.id]?.weight || 1;
        const bWeight = TERRAIN_TYPES[b.loc.id]?.weight || 1;
        return aWeight - bWeight; // lower weight = rarer
      })[0]?.loc.name
    : null;

  // Adjectives by theme
  const adjectives = {
    fantasy: ["Sacred", "Ancient", "Whispering", "Cursed", "Hidden", "Eternal", "Forgotten"],
    cyberpunk: ["Abandoned", "Neon", "Fractured", "Silent", "Bleeding", "Data-Lit", "Fallen"],
    modern: ["Quiet", "Tree-Lined", "Busy", "Riverside", "Hillside", "Empty", "Sunlit"]
  };
  const adj = adjectives[theme] ? adjectives[theme][Math.floor(Math.random() * adjectives[theme].length)] : "Mysterious";

  // Name patterns
  const patterns = [
    `${adj} ${terrainLabel}`,
    `${iconicLocation ? iconicLocation : `The ${adj} Site`} in the ${terrainLabel}`,
    `${iconicLocation ? `${iconicLocation} of` : `The ${adj} Realm of`} the ${terrainLabel}`,
    `The ${adj} ${iconicLocation || "Place"} by the ${terrainLabel}`,
    `Where the ${terrainLabel} Begins`
  ];

  return patterns[Math.floor(Math.random() * patterns.length)];
}




  static stringToSeed(str) {
    let seed = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      seed = ((seed << 5) - seed + char) & 0xffffffff;
    }
    return Math.abs(seed) % 1000000;
  }
}

==================================================
FILE: js\classes\WatercolorOverlay.js
MODIFIED: 2025-09-06 01:06:15
TOKENS: [92m1,664[0m
==================================================

// js/classes/WatercolorOverlay.js
class WatercolorOverlay {
    constructor(mapArea, width, height, tileSize, seed) {
        this.mapArea = mapArea;
        this.width = width;
        this.height = height;
        this.tileSize = tileSize;
        this.seed = seed;

        // Create contexts
        this.parchmentCanvas = document.getElementById("parchmentCanvas");
        this.watercolorCanvas = document.getElementById("watercolorCanvas");

        if (!this.parchmentCanvas || !this.watercolorCanvas) {
            console.warn("Canvases not found. Skipping watercolor overlay.");
            return;
        }

        this.parchmentCtx = this.parchmentCanvas.getContext("2d");
        this.ctx = this.watercolorCanvas.getContext("2d");

        this.resize();
        window.addEventListener("resize", () => this.resize());

        // Draw parchment once
        this.drawParchment();
    }

    resize() {
        const rect = this.mapArea.getBoundingClientRect();
        const scale = window.devicePixelRatio || 1;

        this.parchmentCanvas.width = rect.width * scale;
        this.parchmentCanvas.height = rect.height * scale;
        this.watercolorCanvas.width = rect.width * scale;
        this.watercolorCanvas.height = rect.height * scale;

        this.parchmentCanvas.style.width = `${rect.width}px`;
        this.parchmentCanvas.style.height = `${rect.height}px`;
        this.watercolorCanvas.style.width = `${rect.width}px`;
        this.watercolorCanvas.style.height = `${rect.height}px`;

        this.parchmentCtx.scale(scale, scale);
        this.ctx.scale(scale, scale);
    }

    drawParchment() {
        const w = this.parchmentCanvas.width / (window.devicePixelRatio || 1);
        const h = this.parchmentCanvas.height / (window.devicePixelRatio || 1);
        const imageData = this.parchmentCtx.createImageData(w, h);
        for (let i = 0; i < imageData.data.length; i += 4) {
            const value = 245 + Math.random() * 10;
            const tint = Math.random() > 0.9 ? 10 : 0;
            imageData.data[i] = value + tint; // R
            imageData.data[i + 1] = value - 10 + tint; // G
            imageData.data[i + 2] = value - 30; // B
            imageData.data[i + 3] = 255; // A
        }
        this.parchmentCtx.putImageData(imageData, 0, 0);

        // Lighten with screen blend
        this.parchmentCtx.globalCompositeOperation = "screen";
        this.parchmentCtx.fillStyle = "rgba(255, 255, 220, 0.1)";
        this.parchmentCtx.fillRect(0, 0, w, h);
        this.parchmentCtx.globalCompositeOperation = "source-over";
    }

    drawGrain(x, y, size, color, alpha) {
        this.ctx.save();
        this.ctx.globalAlpha = alpha;
        this.ctx.fillStyle = color;
        for (let i = 0; i < 6; i++) {
            const rx = x - size / 2 + Math.random() * size;
            const ry = y - size / 2 + Math.random() * size;
            this.ctx.fillRect(rx, ry, 1, 1);
        }
        this.ctx.restore();
    }

    drawFluffyBlob(x, y, rgb, size = 4) {
        this.ctx.save();
        const angle = Math.random() * Math.PI * 2;
        this.ctx.translate(x, y);
        this.ctx.rotate(angle);

        const numLayers = 8;
        const maxRadius = size * 1.2;

        for (let i = 0; i < numLayers; i++) {
            const r = maxRadius * (i / numLayers);
            const opacity = 0.15 - i * 0.015;
            const jitterX = Math.random() * 15 - 7.5;
            const jitterY = Math.random() * 15 - 7.5;

            const noise = (min, max) => Math.random() * (max - min) + min;
            const some_num = 10;
            this.ctx.fillStyle = `rgba(${rgb.r + noise(-some_num, some_num)}, ${rgb.g + noise(-some_num, some_num)}, ${rgb.b + noise(-some_num, some_num)}, ${opacity})`;

            this.ctx.beginPath();
            this.ctx.arc(jitterX, jitterY, r, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.restore();
    }

    render(grid, theme) {
        // Reset watercolor canvas
        this.ctx.clearRect(0, 0, this.watercolorCanvas.width, this.watercolorCanvas.height);

        // Use WFC seed for determinism
        Math.seedrandom(this.seed);

        // Define draw order: heaviest on top
        const DRAW_ORDER = ["spire", "forest", "meadow", "barrens", "water"];

        // Configurable density per terrain
        const BLOB_DENSITY = {
            spire: 0.7,
            forest: 0.5,
            meadow: 0.4,
            barrens: 0.3,
            water: 0.4,
        };

        const getBlobCount = (terrain) => {
            return BLOB_DENSITY[terrain] || 0.3;
        };

        // For each terrain type, in draw order
        for (const terrainType of DRAW_ORDER) {
            const visual = theme.elevation[terrainType];
            if (!visual) continue;

            const baseColor = visual.colors[0];
            const rgb = this.hexToRgb(baseColor);

            for (let y = 0; y < this.height; y++) {
                for (let x = 0; x < this.width; x++) {
                    const cell = grid[y][x];
                    if (cell.terrain !== terrainType) continue;

                    if (Math.random() > getBlobCount(terrainType)) continue;

                    const tileRect = this.getTileRect(x, y);
                    const cx = tileRect.x + this.tileSize / 2;
                    const cy = tileRect.y + this.tileSize / 2;

                    // Blob size slightly larger than tile to bleed
                   // const blobSize = this.tileSize * 1.8;
                    const blobSize = this.tileSize * 0.8;
                    this.drawFluffyBlob(cx, cy, rgb, blobSize);

                    // Optional: Add subtle grain per blob
                    // this.drawGrain(cx, cy, blobSize, `rgba(${rgb.r},${rgb.g},${rgb.b},0.1)`, 0.05);
                }
            }
        }

        // Restore global randomness
        Math.seedrandom();

        console.log("üé® Watercolor overlay rendered");
    }

    getTileRect(x, y) {
  const gridEl = document.getElementById("mapGrid");
  const rect = gridEl.getBoundingClientRect();
  const tileSize = this.tileSize;
  return {
    x: x * tileSize,
    y: y * tileSize,
    width: tileSize,
    height: tileSize,
  };
}

    hexToRgb(hex) {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return { r, g, b };
    }

    clear() {
        this.parchmentCtx.clearRect(0, 0, this.parchmentCanvas.width, this.parchmentCanvas.height);
        this.ctx.clearRect(0, 0, this.watercolorCanvas.width, this.watercolorCanvas.height);
    }
}


==================================================
FILE: js\classes\WaveFunctionCollapse.js
MODIFIED: 2025-09-06 01:27:35
TOKENS: [92m3,225[0m
==================================================

// js/classes/WaveFunctionCollapse.js
class WaveFunctionCollapse {
  
    constructor(width, height, themeName) {
        this.width = width;
        this.height = height;
        this.themeName = themeName;
        this.grid = [];
        this.stepCount = 0;
        this.locationCount = 0;
        this.isGenerating = false;
        this.autoSpeed = 0;
        this.placedLocations = [];
        this.mapName = "";
        this.init();
    }

    init() {
        this.grid = [];
        this.stepCount = 0;
        this.locationCount = 0;
        this.placedLocations = [];
        for (let y = 0; y < this.height; y++) {
            this.grid[y] = [];
            for (let x = 0; x < this.width; x++) {
                this.grid[y][x] = {
                    possibilities: Object.keys(TERRAIN_TYPES),
                    collapsed: false,
                    terrain: null,
                    location: null,
                };
            }
        }
        this.log(`Initialized ${this.width}x${this.height} grid`);
        this.updateUI();
    }

    getCell(x, y) {
        if (x < 0 || x >= this.width || y < 0 || y >= this.height) return null;
        return this.grid[y][x];
    }

    getNeighbors(x, y) {
        const directions = [
            [-1, 0],
            [1, 0],
            [0, -1],
            [0, 1],
        ];
        return directions.map(([dx, dy]) => ({ x: x + dx, y: y + dy, cell: this.getCell(x + dx, y + dy) })).filter((n) => n.cell);
    }

    findLowestEntropy() {
        let minEntropy = Infinity;
        let candidates = [];
        for (let y = 0; y < this.height; y++) {
            for (let x = 0; x < this.width; x++) {
                const cell = this.grid[y][x];
                if (!cell.collapsed && cell.possibilities.length < minEntropy) {
                    minEntropy = cell.possibilities.length;
                    candidates = [{ x, y }];
                } else if (!cell.collapsed && cell.possibilities.length === minEntropy) {
                    candidates.push({ x, y });
                }
            }
        }
        return candidates.length > 0 ? candidates[Math.floor(Math.random() * candidates.length)] : null;
    }

    collapseCell(x, y) {
        const cell = this.grid[y][x];
        if (cell.collapsed) return false;

        let weights = {};
        for (const t of cell.possibilities) {
            let weight = TERRAIN_TYPES[t].weight;
            const neighborMatchCount = this.getNeighbors(x, y).filter((n) => n.cell.collapsed && n.cell.terrain === t).length;
            weight *= Math.pow(1.7, neighborMatchCount);
            weights[t] = weight;
        }

        const totalWeight = Object.values(weights).reduce((a, b) => a + b, 0);
        if (totalWeight === 0) return false;

        let r = Math.random() * totalWeight;
        let selected = cell.possibilities[0];
        for (const t of cell.possibilities) {
            r -= weights[t];
            if (r <= 0) {
                selected = t;
                break;
            }
        }

        const theme = ThemeManager.current;
        const terrainVisual = theme.elevation[selected];
        const chosenColor = ThemeManager.getRandomColor(terrainVisual.colors);

        cell.terrain = selected;
        cell.possibilities = [selected];
        cell.collapsed = true;
        cell.color = chosenColor;

        this.log(`Collapsed (${x}, ${y}) ‚Üí ${selected}`);
        return true;
    }

    propagate(x, y) {
        const queue = [{ x, y }];
        const processed = new Set();
        while (queue.length > 0) {
            const { x, y } = queue.shift();
            const key = `${x},${y}`;
            if (processed.has(key)) continue;
            processed.add(key);
            const neighbors = this.getNeighbors(x, y);
            for (const { x: nx, y: ny, cell: neighbor } of neighbors) {
                if (neighbor.collapsed) continue;
                const valid = neighbor.possibilities.filter((p) => {
                    const allowed = TERRAIN_TYPES[p].adjacent;
                    return this.getNeighbors(nx, ny).some(({ cell: nn }) => (nn.collapsed ? allowed.includes(nn.terrain) : true));
                });
                if (valid.length !== neighbor.possibilities.length) {
                    neighbor.possibilities = valid;
                    if (valid.length === 0) {
                        this.log(`Contradiction at (${nx}, ${ny})`);
                        return false;
                    }
                    queue.push({ x: nx, y: ny });
                }
            }
        }
        return true;
    }

    step() {
        if (this.isComplete()) return false;
        const cell = this.findLowestEntropy();
        if (!cell) return false;
        if (this.collapseCell(cell.x, cell.y)) {
            if (!this.propagate(cell.x, cell.y)) {
                this.log("Contradiction!");
                return false;
            }
            this.stepCount++;
            this.updateUI();
            const el = document.querySelector(`[data-pos="${cell.x},${cell.y}"]`);
            if (el) {
                el.classList.add("collapsed");
                setTimeout(() => el.classList.remove("collapsed"), 500);
            }
            return true;
        }
        return false;
    }

    isComplete() {
        return this.grid.flat().every((c) => c.collapsed);
    }

    placeLocations() {
        const cells = [];
        for (let y = 0; y < this.height; y++) {
            for (let x = 0; x < this.width; x++) {
                if (!this.grid[y][x].location) {
                    cells.push({ x, y });
                }
            }
        }

        const sortedLocations = [...LOCATIONS].sort((a, b) => {
            const countValid = (loc) => cells.filter((pos) => this.isValidLocationSpot(pos.x, pos.y, loc)).length;
            return countValid(a) - countValid(b);
        });

        for (const loc of sortedLocations) {
            const validSpots = cells.filter((pos) => this.isValidLocationSpot(pos.x, pos.y, loc));
            if (validSpots.length === 0) continue;
            const pick = validSpots[Math.floor(Math.random() * validSpots.length)];
            const { x, y } = pick;
            this.grid[y][x].location = loc;
            this.placedLocations.push({ x, y, loc });
            this.locationCount++;
            this.log(`üìç Placed ${loc.name} at (${x}, ${y})`);
            const idx = cells.findIndex((c) => c.x === x && c.y === y);
            if (idx !== -1) cells.splice(idx, 1);
        }
    }

    isValidLocationSpot(x, y, location) {
        const cell = this.grid[y][x];
        if (cell.location) return false;
        const terrain = cell.terrain;
        const rules = location.rules;

        if (rules.on && !rules.on.includes(terrain)) return false;

        if (rules.adjacent && rules.adjacent.length > 0) {
            const neighborTerrains = this.getNeighbors(x, y)
                .filter((n) => n.cell.collapsed)
                .map((n) => n.cell.terrain);
            const hasAllRequired = rules.adjacent.every((req) => neighborTerrains.includes(req));
            if (!hasAllRequired) return false;
        }

        const tooClose = this.placedLocations.some((p) => Math.abs(x - p.x) + Math.abs(y - p.y) < 3);
        if (tooClose) return false;

        return true;
    }

    async autoGenerate() {
        if (this.isGenerating) return;

        // Use manual name if provided, else generate
        //const input = document.getElementById("mapNameInput");
        // const userInput = input?.value.trim(); // Safe access

        // Use manual name if provided, else generate
        //this.mapName = userInput || MapNamer.generate(this);

        const input = document.getElementById("mapNameInput");
        const userInput = input?.value.trim();
        this.mapName = userInput || MapNamer.generate(this);

        const seedValue = MapNamer.stringToSeed(this.mapName);
        Math.seedrandom?.(seedValue);

        this.isGenerating = true;
        this.init();
        TemplatePlacer.applyTo(this);

        let attempts = 0;
        const max = this.width * this.height * 2;
        while (!this.isComplete() && attempts < max && this.isGenerating) {
            if (!this.step()) {
                this.log("Restarting...");
                this.init();
                TemplatePlacer.applyTo(this);
                attempts = 0;
            } else {
                attempts++;
            }
            await this.sleep(this.autoSpeed);
        }

        if (this.isComplete() && this.isGenerating) {
            this.placeLocations();

            // Now re-generate name *based on final map* (but don't override user input)
            const finalName = MapNamer.generate(this);
            if (!document.getElementById("mapNameInput").value) {
                this.mapName = finalName;
            }

            // ‚úÖ Add: Render watercolor overlay
            if (window.watercolorOverlay) {
                window.watercolorOverlay.render(this.grid, ThemeManager.current);
            }

            // Update placeholder only if not overridden
            this.updateMapName();

            this.log(`üåç Final Name: "${finalName}"`);
            this.log("üéâ Complete with locations!");
        }
        this.isGenerating = false;
        this.updateUI();
    }

    sleep(ms) {
        return new Promise((r) => setTimeout(r, ms));
    }

    updateUI() {
        this.renderGrid();
        this.updateProgress();
        this.updateStats();
        this.updateMapName();
    }


















renderGrid() {
  const container = document.getElementById("mapGrid");
  if (!container || !this.width || !this.height) return;

  // Ensure grid is initialized
  if (!this.grid || this.grid.length === 0) {
    console.warn("Grid not initialized yet");
    return;
  }

  const w = this.width;
  const h = this.height;
  const maxTileSize = 600 / Math.max(w, h);
  const tileSize = Math.min(48, maxTileSize);

  // Apply grid structure
  container.style.display = "grid";
  container.style.gridTemplateColumns = `repeat(${w}, ${tileSize}px)`;
  container.style.gridTemplateRows = `repeat(${h}, ${tileSize}px)`;
  container.style.gap = "0";
  container.style.border = "none";
  container.style.justifyContent = "center";
  container.style.alignItems = "center";

  // Clear and re-render
  container.innerHTML = "";

  for (let y = 0; y < h; y++) {
    for (let x = 0; x < w; x++) {
      const cell = this.grid[y][x];
      const tile = document.createElement("div");
      tile.className = "tile";
      tile.dataset.pos = `${x},${y}`;

      if (cell.collapsed) {
        const theme = ThemeManager.current;
        const visual = theme.elevation[cell.terrain];
        tile.style.backgroundColor = visual?.colors[0] || "#374151";
        if (cell.location) {
          const locTheme = theme.locations[cell.location.id];
          tile.classList.add("location");
          tile.textContent = locTheme?.emoji || cell.location.emoji;
          tile.title = locTheme?.label || cell.location.name;
        }
      } else {
        tile.style.backgroundColor = "#374151"; // uncollapsed color
      }

      tile.style.width = `${tileSize}px`;
      tile.style.height = `${tileSize}px`;
      container.appendChild(tile);
    }
  }
}





















    

    renderGrid_old() {
        const container = document.getElementById("mapGrid");
        const w = this.width;
        const h = this.height;
        const tileSize = Math.min(48, 600 / Math.max(w, h));
        container.style.cssText = `
      grid-template-columns: repeat(${w}, ${tileSize}px);
      grid-template-rows: repeat(${h}, ${tileSize}px);
      gap: 0;
    `;
        container.innerHTML = "";

        for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
                const cell = this.grid[y][x];
                const tile = document.createElement("div");
                tile.className = "tile";
                tile.dataset.pos = `${x},${y}`;

                if (cell.collapsed) {
                    // ‚úÖ Keep location rendering
                    if (cell.location) {
                      //  const locTheme = theme.locations[cell.location.id];
                        const locTheme = ThemeManager.current.locations[cell.location.id];
                        tile.classList.add("location");
                        tile.textContent = locTheme?.emoji || cell.location.emoji;
                        tile.title = locTheme?.label || cell.location.name;
                    }
                    // ‚ùå Remove terrain background
                    // tile.style.backgroundColor = visual?.colors[0] || "#374151";
                    // ‚úÖ Make tile transparent
                    tile.style.backgroundColor = "transparent";
                } else {
                    tile.style.backgroundColor = "#374151";
                }

                tile.style.width = `${tileSize}px`;
                tile.style.height = `${tileSize}px`;
                container.appendChild(tile);
            }
        }
    }

    updateProgress() {
        const total = this.width * this.height;
        const done = this.grid.flat().filter((c) => c.collapsed).length;
        const p = Math.round((done / total) * 100);
        const bar = document.getElementById("progressBar");
        bar.style.width = `${p}%`;
        bar.textContent = `${p}%`;
    }

    updateStats() {
        document.getElementById("stepCount").textContent = this.stepCount;
        document.getElementById("locationCount").textContent = this.locationCount;
        const unCollapsed = this.grid.flat().filter((c) => !c.collapsed);
        const entropy = unCollapsed.reduce((sum, c) => sum + c.possibilities.length, 0);
        const collapsed = this.grid.flat().filter((c) => c.collapsed).length;
        document.getElementById("entropyCount").textContent = entropy;
        document.getElementById("collapsedCount").textContent = collapsed;
    }

    updateMapName() {
        const input = document.getElementById("mapNameInput");
        if (!input) return;

        // Only update placeholder if user hasn't typed anything
        if (!input.value) {
            input.placeholder = this.mapName || "Unnamed World";
        }
    }

    log(msg) {
        const log = document.getElementById("log");
        const time = new Date().toLocaleTimeString();
        log.innerHTML += `<div>[${time}] ${msg}</div>`;
        log.scrollTop = log.scrollHeight;
    }
}


==================================================
FILE: themes\cyberpunk.json
MODIFIED: 2025-09-05 13:06:37
TOKENS: [92m920[0m
==================================================

{
  "name": "Cyberpunk",
  "description": "A courier navigating zones of privilege and shadow",
  "elevation": {
    "spire": {
      "label": "Corporate Hi-Rise",
      "colors": ["#777", "#1A1A3F", "#2A2A5F"],
      "weight": 10,
      "adjacent": ["enclave", "wasteland"]
    },
    "enclave": {
      "label": "Gated Enclaves",
      "colors": ["#16A34A", "#374151", "#4B5563"],
      "weight": 15,
      "adjacent": ["enclave", "core", "spire"]
    },
    "core": {
      "label": "The City",
      "colors": ["#467fa1", "#2A2A3A", "#3A3A4A"],
      "weight": 30,
      "adjacent": ["core", "canal", "enclave", "wasteland"]
    },
    "canal": {
      "label": "The Slums",
      "colors": ["#54295c", "#33F0FF", "#66F9FF"],
      "weight": 18,
      "adjacent": ["canal", "core", "wasteland"]
    },
    "wasteland": {
      "label": "The Wasteland",
      "colors": ["#7C2D12", "#9A3412", "#C2410C"],
      "weight": 8,
      "adjacent": ["wasteland", "core", "canal"]
    }
  },
  "locations": {
    "safehouse": { "label": "Safehouse", "emoji": "üîê", "rules": { "on": ["core"], "adjacent": ["wasteland"] } },
    "neotower": { "label": "Neo-Tower", "emoji": "üóº", "rules": { "on": ["spire"] } },
    "hub": { "label": "Central Hub", "emoji": "üìç", "rules": { "on": ["core"], "adjacent": ["enclave"] } },
    "forge": { "label": "Tech Forge", "emoji": "üîß", "rules": { "on": ["wasteland"], "adjacent": ["canal"] } },
    "sanctum": { "label": "Data Sanctum", "emoji": "üíæ", "rules": { "on": ["spire"], "adjacent": ["enclave"] } },
    "junction": { "label": "Net Junction", "emoji": "üåê", "rules": { "on": ["core"], "adjacent": ["canal", "wasteland"] } },
    "slumlord": { "label": "Slum Lord's Den", "emoji": "üíÄ", "rules": { "on": ["wasteland"] } },
    "vault": { "label": "Neural Vault", "emoji": "üß†", "rules": { "on": ["wasteland"], "adjacent": ["canal"] } },
    "beacon": { "label": "Signal Beacon", "emoji": "üì°", "rules": { "on": ["spire"], "adjacent": ["core"] } },
    "clinic": { "label": "Bio-Clinic", "emoji": "üíâ", "rules": { "on": ["core"], "adjacent": ["enclave"] } }
  },
  "templates": {
    "data_river": {
      "weight": 4,
      "placement": "any",
      "pattern": [
        ["core", "canal", "core"],
        ["core", "canal", "core"],
        ["wasteland", "canal", "enclave"]
      ]
    },
    "spire_fortress": {
      "weight": 2,
      "placement": "center",
      "pattern": [
        ["spire", "spire", "spire"],
        ["spire", "spire", "spire"],
        ["enclave", "enclave", "wasteland"]
      ]
    }
  }
}

==================================================
FILE: themes\fantasy.json
MODIFIED: 2025-09-05 12:34:21
TOKENS: [92m946[0m
==================================================

{
  "name": "Fantasy",
  "description": "A quiet journey through enchanted lands",
  "elevation": {
    "spire": {
      "label": "Ancient Peaks",
      "colors": ["#777", "#4B5563", "#6B7280"],
      "weight": 12,
      "adjacent": ["forest", "barrens"]
    },
    "forest": {
      "label": "Whispering Woods",
      "colors": ["#16A34A", "#15803D", "#166534"],
      "weight": 30,
      "adjacent": ["forest", "meadow", "spire"]
    },
    "meadow": {
      "label": "Sunlit Glades",
      "colors": ["#A3E635", "#84CC16", "#65A30D"],
      "weight": 20,
      "adjacent": ["meadow", "forest", "water"]
    },
    "water": {
      "label": "Glass Rivers",
      "colors": ["#1D4ED8", "#2563EB", "#3B82F6"],
      "weight": 18,
      "adjacent": ["water", "meadow", "barrens"]
    },
    "barrens": {
      "label": "Cursed Lands",
      "colors": ["#7C2D12", "#9A3412", "#C2410C"],
      "weight": 5,
      "adjacent": ["spire", "forest", "barrens"]
    }
  },
  "locations": {
    "cottage": { "label": "Hermit's Cottage", "emoji": "üõñ", "rules": { "on": ["forest"], "adjacent": ["water"] } },
    "peak": { "label": "Dragon's Perch", "emoji": "üêâ", "rules": { "on": ["spire"] } },
    "sanctum": { "label": "Crystal Sanctum", "emoji": "üîÆ", "rules": { "on": ["spire"], "adjacent": ["barrens"] } },
    "ruins": { "label": "Fallen Temple", "emoji": "üèõÔ∏è", "rules": { "on": ["barrens"], "adjacent": ["spire"] } },
    "lighthouse": { "label": "Lantern Tower", "emoji": "üóº", "rules": { "on": ["meadow"], "adjacent": ["water"] } },
    "wharf": { "label": "River Wharf", "emoji": "‚öì", "rules": { "on": ["meadow", "water"], "adjacent": ["forest"] } },
    "crossroads": { "label": "Fae Crossroads", "emoji": "üõ£Ô∏è", "rules": { "on": ["forest"], "adjacent": ["meadow", "spire"] } },
    "mines": { "label": "Gem Caverns", "emoji": "üíé", "rules": { "on": ["spire"], "adjacent": ["barrens"] } },
    "grove": { "label": "Sacred Grove", "emoji": "üå≥", "rules": { "on": ["forest"] } },
    "ford": { "label": "Stone Ford", "emoji": "ü™®", "rules": { "on": ["water"], "adjacent": ["meadow"] } }
  },
  "templates": {
    "river_flow": {
      "weight": 4,
      "placement": "any",
      "pattern": [
        [null, "meadow", "water", "meadow", null],
        [null, "meadow", "water", "meadow", null],
        ["forest", "forest", "water", "forest", "forest"],
        ["forest", "forest", "water", "forest", "forest"],
        [null, "meadow", "water", "meadow", null]
      ]
    },
    "mountain_heart": {
      "weight": 2,
      "placement": "center",
      "pattern": [
        ["spire", "spire", "spire"],
        ["spire", "spire", "spire"],
        ["forest", "forest", "barrens"]
      ]
    }
  }
}

==================================================
FILE: themes\modern.json
MODIFIED: 2025-09-05 12:58:06
TOKENS: [92m892[0m
==================================================

{
  "name": "Modern",
  "description": "A courier biking through city rhythms and quiet corners",
  "elevation": {
    "estates": {
      "label": "Hillside Estates",
      "colors": ["#10B981", "#6B7280", "#4B5563"],
      "weight": 12,
      "adjacent": ["suburbia", "tracks"]
    },
    "suburbia": {
      "label": "Tree-Lined Suburbia",
      "colors": ["#16A34A", "#F3F4F6", "#E5E7EB"],
      "weight": 25,
      "adjacent": ["suburbia", "downtown", "estates"]
    },
    "downtown": {
      "label": "Downtown Blocks",
      "colors": ["#9CA3AF", "#059669", "#047857"],
      "weight": 30,
      "adjacent": ["downtown", "river", "suburbia", "tracks"]
    },
    "river": {
      "label": "Riverside Path",
      "colors": ["#0EA5E9", "#0284C7", "#0369A1"],
      "weight": 18,
      "adjacent": ["river", "downtown", "tracks"]
    },
    "tracks": {
      "label": "Wrong Side of Tracks",
      "colors": ["#374151", "#1F2937", "#111827"],
      "weight": 8,
      "adjacent": ["tracks", "downtown", "river"]
    }
  },
  "locations": {
    "shed": { "label": "Garden Shed", "emoji": "üè°", "rules": { "on": ["downtown"], "adjacent": ["river"] } },
    "observatory": { "label": "Hilltop Observatory", "emoji": "üî≠", "rules": { "on": ["estates"] } },
    "square": { "label": "Town Square", "emoji": "üìç", "rules": { "on": ["downtown"], "adjacent": ["suburbia"] } },
    "shop": { "label": "Repair Shop", "emoji": "üîß", "rules": { "on": ["tracks"], "adjacent": ["river"] } },
    "garden": { "label": "Community Garden", "emoji": "üå±", "rules": { "on": ["downtown"], "adjacent": ["river"] } },
    "circle": { "label": "Traffic Circle", "emoji": "üö¶", "rules": { "on": ["downtown"], "adjacent": ["suburbia"] } },
    "lot": { "label": "Abandoned Lot", "emoji": "üöß", "rules": { "on": ["tracks"] } },
    "warehouse": { "label": "Distribution Hub", "emoji": "üì¶", "rules": { "on": ["tracks"], "adjacent": ["river"] } },
    "bridge": { "label": "Rail Bridge", "emoji": "üåâ", "rules": { "on": ["river"], "adjacent": ["tracks"] } },
    "cafe": { "label": "Corner Cafe", "emoji": "‚òï", "rules": { "on": ["downtown"], "adjacent": ["suburbia"] } }
  },
  "templates": {
    "riverside_path": {
      "weight": 4,
      "placement": "any",
      "pattern": [
        ["downtown", "river", "downtown"],
        ["downtown", "river", "downtown"],
        ["tracks", "river", "suburbia"]
      ]
    },
    "hillside_view": {
      "weight": 2,
      "placement": "center",
      "pattern": [
        ["estates", "estates", "estates"],
        ["estates", "estates", "estates"],
        ["suburbia", "suburbia", "tracks"]
      ]
    }
  }
}

