<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Watercolor Map Overlay - Vanilla JS</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #eee;
      font-family: 'Consolas', monospace;
    }
    canvas {
      display: block;
      background: #f0f0f0;
    }
    .controls {
      position: absolute;
      top: 10px;
      left: 10px;
      padding: 10px;
      background: rgba(255,255,255,0.9);
      border-radius: 6px;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
    }
    .palette {
      display: flex;
      gap: 8px;
      margin-top: 10px;
    }
    .color-swatch {
      width: 30px;
      height: 30px;
      border-radius: 4px;
      cursor: pointer;
      transition: transform 0.1s ease;
    }
    .color-swatch:hover {
      transform: scale(1.1);
    }
    .color-swatch.active {
      border: 2px solid #000;
      transform: scale(1.1);
    }
  </style>
</head>
<body>

  <div class="controls">
    <h3>Colors</h3>
    <div class="palette" id="palette"></div>
  </div>

  <canvas id="canvas"></canvas>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const paletteEl = document.getElementById('palette');

    // Set canvas size
    function resizeCanvas() {
      canvas.width = window.innerWidth * 0.9;
      canvas.height = window.innerHeight * 0.8;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Fantasy theme colors (from fantasy.json)
    const FANTASY_COLORS = [
      { name: "Forest", hex: "#16A34A" },
      { name: "Meadow", hex: "#A3E635" },
      { name: "Water", hex: "#1D4ED8" },
      { name: "Barrens", hex: "#C2410C" },
      { name: "Spire", hex: "#777" }
    ];

    // Initialize color palette
    FANTASY_COLORS.forEach(color => {
      const swatch = document.createElement('div');
      swatch.className = 'color-swatch';
      swatch.style.backgroundColor = color.hex;
      swatch.dataset.hex = color.hex;
      swatch.title = color.name;
      swatch.addEventListener('click', () => {
        selectedColor = color.hex;
        swatch.classList.add('active');
        document.querySelectorAll('.color-swatch').forEach(el => {
          if (el !== swatch) el.classList.remove('active');
        });
      });
      paletteEl.appendChild(swatch);
    });

    let selectedColor = FANTASY_COLORS[0].hex;

    // Draw parchment texture (base layer)
    function drawParchmentTexture() {
      const w = canvas.width;
      const h = canvas.height;
      const imageData = ctx.createImageData(w, h);
      for (let i = 0; i < imageData.data.length; i += 4) {
        const value = 245 + Math.random() * 10;
        const tint = Math.random() > 0.9 ? 10 : 0;
        imageData.data[i] = value + tint; // R
        imageData.data[i + 1] = value - 10 + tint; // G
        imageData.data[i + 2] = value - 30; // B
        imageData.data[i + 3] = 255; // A
      }
      ctx.putImageData(imageData, 0, 0);

      // Lighten base with screen blend
      ctx.globalCompositeOperation = "screen";
      ctx.fillStyle = "rgba(255, 255, 220, 0.1)";
      ctx.fillRect(0, 0, w, h);
      ctx.globalCompositeOperation = "source-over"; // Reset
    }

    // Draw grain (paper texture)
    function drawGrain(cx, cy, size, color, alpha) {
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.fillStyle = color;
      for (let i = 0; i < 6; i++) {
        const rx = cx - size / 2 + Math.random() * size;
        const ry = cy - size / 2 + Math.random() * size;
        ctx.fillRect(rx, ry, 1, 1);
      }
      ctx.restore();
    }

    // Draw fluffy blob (soft, blurred-like effect)
    function drawFluffyBlob(x, y, rgb, size = 40) {
      ctx.save();
      const angle = Math.random() * Math.PI * 2;
      ctx.translate(x, y);
      ctx.rotate(angle);

      const numLayers = 8;
      const maxRadius = size * 1.2;

      for (let i = 0; i < numLayers; i++) {
        const r = maxRadius * (i / numLayers);
        const opacity = 0.15 - (i * 0.015); // Fade out
        const jitterX = Math.random() * 15 - 7.5;
        const jitterY = Math.random() * 15 - 7.5;

        const some_num = 10
        ctx.fillStyle = `rgba(${rgb.r + noise(-some_num,some_num)}, ${rgb.g + noise(-some_num,some_num)}, ${rgb.b + noise(-some_num,some_num)}, ${opacity})`;

        ctx.beginPath();
        ctx.arc(jitterX, jitterY, r, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.restore();
    }

    // Helper: random with range
    function noise(min, max) {
      return Math.random() * (max - min) + min;
    }

    // Convert hex to RGB
    function hexToRgb(hex) {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      return { r, g, b };
    }

    // Mouse interaction
    let isDrawing = false;
    let lastX, lastY;

    canvas.addEventListener('mousedown', startDrawing);
    canvas.addEventListener('mousemove', draw);
    canvas.addEventListener('mouseup', stopDrawing);
    canvas.addEventListener('mouseleave', stopDrawing);

    function startDrawing(e) {
      isDrawing = true;
      [lastX, lastY] = [e.offsetX, e.offsetY];
    }

    function draw(e) {
      if (!isDrawing) return;

      const x = e.offsetX;
      const y = e.offsetY;

      // Only draw every 100ms
      if (Date.now() - lastDrawTime < 50) return;
      lastDrawTime = Date.now();

      const rgb = hexToRgb(selectedColor);
      drawFluffyBlob(x, y, rgb, 25);
    }

    function stopDrawing() {
      isDrawing = false;
    }

    // Initial setup
    let lastDrawTime = 0;

    // Draw parchment background once
    drawParchmentTexture();

    // Add grain texture (optional)
    for (let i = 0; i < 100; i++) {
      const x = Math.random() * canvas.width;
      const y = Math.random() * canvas.height;
      drawGrain(x, y, 10, '#333', 0.05);
    }

    // Optional: Add subtle vignette
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,0.05)';
    ctx.beginPath();
    ctx.arc(canvas.width / 2, canvas.height / 2, canvas.width * 0.8, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  </script>

</body>
</html>