<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Fantasy Topographic Map</title>
        <style>
            body {
                margin: 0;
                background-color: #e7c496; /* Parchment background */
                display: flex;
                justify-content: center;
                align-items: center;
                height: 100vh;
                font-family: "Courier New", monospace;
            }
            canvas {
                border: none;
                box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
            }
            .info {
                position: absolute;
                top: 10px;
                left: 10px;
                color: #333;
                font-size: 14px;
            }
        </style>
    </head>
    <body>
        <div class="info">Fantasy Topographic Map - Seamless & Painterly</div>
        <canvas id="mapCanvas" width="384" height="384"></canvas>

        <script>
            const canvas = document.getElementById("mapCanvas");
            const ctx = canvas.getContext("2d");
            const tilesize = 48;
            const tilesize_exp = 2;

            // Biome colors (adjusted for warmth)
            const biomeColors = {
                water: { r: 50, g: 100, b: 180, alpha: 0.7 },
                plains: { r: 130, g: 170, b: 80, alpha: 0.6 },
                forest: { r: 30, g: 100, b: 50, alpha: 0.7 },
                mountain: { r: 110, g: 110, b: 110, alpha: 0.9 },
                cursed: { r: 160, g: 30, b: 60, alpha: 0.7 },
            };

            // Map data (8x8) from your image
            const map = [
                ["water", "forest", "mountain", "water", "water", "water", "water", "water"],
                ["water", "water", "water", "forest", "forest", "plains", "forest", "forest"],
                ["water", "water", "forest", "forest", "plains", "plains", "plains", "forest"],
                ["forest", "forest", "forest", "plains", "plains", "mountain", "mountain", "mountain"],
                ["forest", "forest", "plains", "plains", "plains", "mountain", "mountain", "cursed"],
                ["plains", "plains", "plains", "plains", "mountain", "mountain", "cursed", "cursed"],
                ["plains", "plains", "mountain", "mountain", "mountain", "cursed", "cursed", "cursed"],
                ["mountain", "mountain", "mountain", "cursed", "cursed", "cursed", "cursed", "cursed"],
            ];

            // Noise function
            function noise(min, max) {
                return Math.random() * (max - min) + min;
            }

            // Draw soft tile with radial gradient (no borders)
            function drawSoftTile(x, y, color) {
                const size = tilesize;
                const margin = 0; // No margin — full tile coverage

                const grad = ctx.createRadialGradient(x + (tilesize / 2 + tilesize_exp), y + (tilesize / 2 + tilesize_exp), 10, x + (tilesize / 2 + tilesize_exp), y + (tilesize / 2 + tilesize_exp), tilesize);
                grad.addColorStop(0, `rgba(${color.r}, ${color.g}, ${color.b}, ${color.alpha})`);
                grad.addColorStop(1, `rgba(${color.r}, ${color.g}, ${color.b}, 0)`);

                ctx.fillStyle = grad;
                ctx.fillRect(x, y, size, size);
            }

            // Draw blend stroke between two biomes (soft transition)
            function drawBlendStroke(x1, y1, x2, y2, colorA, colorB) {
                const dx = x2 - x1;
                const dy = y2 - y1;
                const len = Math.sqrt(dx * dx + dy * dy);
                const width = 25 + noise(0, 15);

                const grad = ctx.createLinearGradient(x1, y1, x2, y2);
                grad.addColorStop(0, `rgba(${colorA.r}, ${colorA.g}, ${colorA.b}, 0.3)`);
                grad.addColorStop(1, `rgba(${colorB.r}, ${colorB.g}, ${colorB.b}, 0.3)`);

                ctx.strokeStyle = grad;
                ctx.lineWidth = width;
                ctx.lineCap = "round";
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }

            // Add subtle elevation shading (darkening at bottom of tiles)
            function addElevationShading(x, y, color) {
                const size = tilesize;
                const grad = ctx.createLinearGradient(x, y, x, y + size);
                grad.addColorStop(0, `rgba(${color.r}, ${color.g}, ${color.b}, ${color.alpha * 0.8})`);
                grad.addColorStop(1, `rgba(${color.r}, ${color.g}, ${color.b}, ${color.alpha * 0.5})`);

                ctx.fillStyle = grad;
                ctx.fillRect(x, y, size, size);
            }

            // Add biome-specific art (painterly details)
            function addBiomeArt(x, y, biome) {
                const cx = x + tilesize / 2;
                const cy = y + tilesize / 2;

                if (biome === "water") {
                    // Gentle wavy lines with more varied curves
                    for (let i = 0; i < 3; i++) {
                        const dy = 10 + i * 15;
                        ctx.strokeStyle = `rgba(50, 100, 180, 0.2)`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(x + 5, y + dy);

                        // More natural curve variation
                        const amp = Math.random() * 16 - 8; // -4 to +4 for subtle wave variation
                        const offset = Math.random() * 20 - 10; // Slight control point shift
                        ctx.quadraticCurveTo(cx + offset, y + dy + amp, x + 43, y + dy);
                        ctx.stroke();
                    }
                } else if (biome === "forest") {
                    // Fluffy tree-like dots
                    for (let i = 0; i < 21; i++) {
                        const nx = cx + noise(-22, 22); // Tighter cluster
                        const ny = cy + noise(-22, 22);
                        const size = 2 + noise(0, 3); // Slightly larger and more varied
                        ctx.fillStyle = `rgba(30, 100, 50, ${0.5 + noise(0, 0.3)})`; // Softer, variable opacity
                        ctx.beginPath();
                        ctx.arc(nx, ny, size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else if (biome === "mountain") {
                    for (let i = 0; i < 3; i++) {
                        const dy = 16 + i * 15;

                        ctx.strokeStyle = `rgba(100, 100, 100, 0.3)`;
                        ctx.lineWidth = 2;

                        // --- Independent random start and end for this line ---
                        const startX = x + 3 + Math.random() * 9; // x + 3  to x + 12
                        const endX = x + 28 + Math.random() * 15; // x + 28 to x + 43

                        // Ensure startX < endX (should always be true, but just in case)
                        if (startX >= endX) continue; // Safety check (extremely unlikely)

                        ctx.beginPath();
                        ctx.moveTo(startX, y + dy);

                        // Random peak: depth and horizontal offset
                        const midX = (startX + endX) / 2;
                        const depth = 8 + Math.random() * 8; // 8–16 px deep
                        const peakOffset = Math.random() * 10 - 5; // ±5 px shift

                        ctx.lineTo(midX + peakOffset, y + dy - depth);
                        ctx.lineTo(endX, y + dy);
                        ctx.stroke();
                    }
                } else if (biome === "cursed") {
                    // Spiky red marks
                    for (let i = 0; i < 7; i++) {
                        const rx = cx + noise(-24, 24);
                        const ry = cy + noise(-24, 24);

                        ctx.save(); // Save current state
                        ctx.translate(rx, ry); // Move origin to the shape center
                        ctx.rotate(noise(0, Math.PI * 2)); // Random rotation
                        ctx.fillStyle = `rgba(160, 30, 60, 0.3)`;
                        ctx.beginPath();
                        ctx.moveTo(0, 0); // Now relative to (rx, ry) due to translate
                        // Make a jagged triangle spike
                        for (let j = 0; j < 5; j++) {
                            const angle = (Math.PI * 2 * j) / 5;
                            const len = 4 + noise(0, 8); // Highly irregular radius → spiky
                            const x = Math.cos(angle) * len;
                            const y = Math.sin(angle) * len;
                            ctx.lineTo(x, y);
                        }
                        ctx.closePath();
                        ctx.fill();
                        ctx.restore(); // Restore original state
                    }
                } else if (biome === "plains") {
                    // Shared wind lean for this group of blades (simulates wind direction)
                    const windLean = Math.random() * 10 - 5; // e.g., -10 to +10 pixels of lean

                    for (let i = 0; i < 7; i++) {
                        const dx = 10 + i * 15; // Horizontal offset

                        ctx.strokeStyle = `rgba(60, 130, 60, ${0.4 + Math.random() * 0.3})`;
                        ctx.lineWidth = 0.5;

                        // Random starting Y within the 43px height box (slightly less to avoid overflow)
                        const startY = y + Math.random() * 38;

                        // Random line length between 8 and 24
                        const length = 2 + Math.random() * 7;

                        // End Y is startY + length (going downward)
                        const endY = startY + length;

                        // Control point Y around the middle of the blade
                        const controlY = startY + length / 2;

                        // Small per-blade wobble
                        const amp = Math.random() * 4 - 2; // Local X variation
                        const offset = Math.random() * 4 - 2; // Local control point Y jitter

                        ctx.beginPath();
                        ctx.moveTo(x + dx, startY);

                        // Apply shared wind lean to the control point and end point
                        // The farther down the blade, the more it leans
                        ctx.quadraticCurveTo(
                            x + dx + windLean + amp, // Base lean + small wobble
                            controlY + offset, // Slight vertical jitter
                            x + dx + windLean, // End point leans with the wind
                            endY
                        );
                        ctx.stroke();
                    }
                }
            }

            // Generate parchment texture (procedural)
            function generateTexture() {
                const texCanvas = document.createElement("canvas");
                texCanvas.width = 512;
                texCanvas.height = 512;
                const texCtx = texCanvas.getContext("2d");

                // Base parchment color
                texCtx.fillStyle = "#e7c496";
                texCtx.fillRect(0, 0, 512, 512);

                // Add grain
                for (let i = 0; i < 1000; i++) {
                    const x = Math.floor(Math.random() * 512);
                    const y = Math.floor(Math.random() * 512);
                    const r = Math.random() * 1.5 + 0.5;
                    texCtx.fillStyle = `rgba(200, 180, 150, ${Math.random() * 0.1})`;
                    texCtx.beginPath();
                    texCtx.arc(x, y, r, 0, Math.PI * 2);
                    texCtx.fill();
                }

                // Add paper fibers
                for (let i = 0; i < 50; i++) {
                    const x1 = Math.random() * 512;
                    const y1 = Math.random() * 512;
                    const x2 = x1 + Math.random() * 200;
                    const y2 = y1 + Math.random() * 200;
                    texCtx.strokeStyle = `rgba(200, 180, 150, 0.1)`;
                    texCtx.lineWidth = 0.5;
                    texCtx.beginPath();
                    texCtx.moveTo(x1, y1);
                    texCtx.lineTo(x2, y2);
                    texCtx.stroke();
                }

                return texCanvas;
            }

            // Main render function
            function renderMap() {
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Set parchment background
                ctx.fillStyle = "#e7c496";
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Step 1: Draw soft tiles (full coverage)
                for (let i = 0; i < 8; i++) {
                    for (let j = 0; j < 8; j++) {
                        const x = i * tilesize;
                        const y = j * tilesize;
                        const biome = map[i][j];
                        drawSoftTile(x, y, biomeColors[biome]);
                    }
                }

                // Step 2: Draw blends between adjacent biomes
                for (let i = 0; i < 8; i++) {
                    for (let j = 0; j < 8; j++) {
                        const current = map[i][j];
                        const x = i * tilesize;
                        const y = j * tilesize;

                        // Right neighbor
                        if (j < 7 && map[i][j + 1] !== current) {
                            drawBlendStroke(x + 48, y + tilesize / 2, x + 48, y + tilesize / 2, biomeColors[current], biomeColors[map[i][j + 1]]);
                        }

                        // Down neighbor
                        if (i < 7 && map[i + 1][j] !== current) {
                            drawBlendStroke(x + tilesize / 2, y + 48, x + tilesize / 2, y + 48, biomeColors[current], biomeColors[map[i + 1][j]]);
                        }
                    }
                }

                // Step 3: Add elevation shading (optional, for depth)
                for (let i = 0; i < 8; i++) {
                    for (let j = 0; j < 8; j++) {
                        const x = i * tilesize;
                        const y = j * tilesize;
                        const biome = map[i][j];
                        addElevationShading(x, y, biomeColors[biome]);
                    }
                }

                // Step 4: Add painterly details
                for (let i = 0; i < 8; i++) {
                    for (let j = 0; j < 8; j++) {
                        const x = i * tilesize;
                        const y = j * tilesize;
                        const biome = map[i][j];
                        addBiomeArt(x, y, biome);
                    }
                }

                // Step 5: Add parchment texture overlay
                const texture = generateTexture();
                ctx.globalAlpha = 0.1;
                ctx.globalCompositeOperation = "multiply";
                ctx.drawImage(texture, 0, 0, 384, 384);
                ctx.globalCompositeOperation = "source-over";
                ctx.globalAlpha = 1.0;
            }

            // Render the map
            renderMap();
        </script>
    </body>
</html>
